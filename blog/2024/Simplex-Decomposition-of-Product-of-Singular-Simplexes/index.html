<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Simplex Decomposition of Product of Singular Simplexes(In Chinese) | Yizhao Chen 陈轶钊 </title> <meta name="author" content="Yizhao Chen 陈轶钊"> <meta name="description" content="Construct a concrete simplex decomposition of product of singular simplexes with an intuitive proof."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png?e89634aa8709fb03c8ab187827e04de4"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Yizhao Chen</span> 陈轶钊 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications&amp;preprints/">Publications &amp; Preprints </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Simplex Decomposition of Product of Singular Simplexes(In Chinese)</h1> <p class="post-meta"> Created in October 17, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#1%E5%BC%95%E5%85%A5">1.引入</a></li> <li class="toc-entry toc-h2"><a href="#2%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%8F%B7">2.一些记号</a></li> <li class="toc-entry toc-h2"> <a href="#3%E5%A5%87%E5%BC%82%E5%8D%95%E5%BD%A2%E7%9A%84%E4%B9%98%E7%A7%AF%E7%9A%84%E5%8D%95%E5%BD%A2%E5%89%96%E5%88%86">3.奇异单形的乘积的单形剖分</a> <ul> <li class="toc-entry toc-h3"><a href="#%E8%A1%A8%E6%A0%BC%E9%87%8C%E7%9A%84%E8%B7%AF%E5%BE%84">表格里的路径</a></li> <li class="toc-entry toc-h3"><a href="#%E5%8D%95%E7%BA%AF%E5%BD%A2%E5%89%96%E5%88%86">单纯形剖分</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#4%E6%80%A7%E8%B4%A8%E4%B8%8E%E6%8E%A8%E8%AE%BA">4.性质与推论</a></li> <li class="toc-entry toc-h2"><a href="#%E9%99%84%E5%BD%95%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%A1%E7%AE%97%E4%BD%8E%E7%BB%B4%E5%A5%87%E5%BC%82%E5%8D%95%E5%BD%A2%E4%B9%98%E7%A7%AF%E7%9A%84%E5%8D%95%E5%BD%A2%E5%89%96%E5%88%86">附录：使用计算机计算低维奇异单形乘积的单形剖分</a></li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="1引入">1.引入</h2> <p>在同调论里，一个很自然的问题是，对于两个拓扑空间\(X,Y\)，它们的乘积\(X\times Y\)的奇异同调群如何用各自的奇异同调群表示。</p> <p>这一问题相当基本，答案看起来也相当明显：我们希望有</p> \[H_*(X\times Y) \cong H_*(X)\otimes H_*(Y).\] <p>不过在试图计算的时候，得到上面的关系会相当麻烦。一个主要的原因是，两个奇异单形的乘积不再是奇异单形。</p> <p>为了让我们的计算能够进行下去，一个办法就是对两个奇异单形\(\sigma, \tau\)的乘积\(\sigma \times \tau\)作单形剖分。依据Gelfand的<em>Methods of Homoligical Algebra</em>，我们这里提供一个剖分的办法（但不会给出证明）。</p> <h2 id="2一些记号">2.一些记号</h2> <p>我们在这一节里介绍之后使用的符号。</p> <ul> <li>\(e_{i-1}\)：\(\mathbb{R}^n(n\geq i)\)中的基向量，也就是第\(i\)个分量为\(1\)，余下分量为\(0\)的向量。因为在每个向量末尾添上\(0\)，可以将\(\mathbb{R}^n\)自然地嵌入到\(\mathbb{R}^{n+1}\)，所以我们后面认为\(e_i\)落在一个维数充分大的向量空间里。</li> <li>\(\Delta^q\)：\(q\)维标准单形，即</li> </ul> \[\{ \sum_{i=0}^q x_i e_i \mid 0\leqslant x_i \leqslant 1, \sum_{i}x_i =1 \}\] <ul> <li>\(\sigma\colon \Delta^p \rightarrow X\)：这是\(X\)中的一个奇异单形，有时我们会用上标来表示\(\sigma\)的维数，即\(\sigma^p\)表明\(\sigma\)是一个\(p\)维单形。</li> <li>\([v_0,v_1, \dots, v_q], v_i \in V\)：表示线性空间\(V\)中的奇异单形：</li> </ul> \[\begin{aligned} \Delta^q &amp; \longrightarrow V \\ \sum_{i=0}^q x_ie_i &amp; \longmapsto \sum_{i=0}^q x_i v_i \end{aligned}\] <ul> <li>\([n]\)：表示集合\(\{0,1,2,\dots, n\}\).</li> </ul> <h2 id="3奇异单形的乘积的单形剖分">3.奇异单形的乘积的单形剖分</h2> <p>我们接下来描述两个奇异单形\(\sigma: \Delta^p \rightarrow X,\tau: \Delta^q \rightarrow Y\)的乘积：</p> \[\sigma \times \tau \colon \Delta^p \times \Delta^q \longrightarrow X \times Y\] <p>的单形剖分：</p> \[m(\sigma, \tau) \in S_{p+q}(X\times Y)\] <h3 id="表格里的路径">表格里的路径</h3> <p>我们将集合\([p]\times [q]\)看作一个\(p\)列、\(q\)行的表格的顶点，每个顶点的横坐标的取值范围为\(0,1,\dots, p\)，纵坐标的取值范围为\(0,1,\dots, q\). 并且表格左下角的顶点为\((0,0)\)，右上角的顶点为\((p,q)\).</p> \[\begin{array}{|l|l|l|l|l|l|} \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \end{array}\] <p>我们从\((0,0)\)出发，每次向上或者向右走一格，一直走到顶点\((p,q)\)，就会得到这个表格中的路径。严格来说，表格里的路径是一个映射：</p> \[\begin{aligned} \gamma\colon [p+q] &amp; \longrightarrow [p]\times [q]. \\ i &amp; \longmapsto \bigl(x(i),y(i)\bigr) \end{aligned}\] <p>满足：</p> \[\begin{gathered} \gamma(0)=(0,0), \ \gamma(p+q)=(p,q)\\ \gamma(i)-\gamma(i-1) \in \{(0,1), (1,0)\}, \forall 1\leqslant i \leqslant p+q.\\ \end{gathered}\] <p>我们将位于\(\gamma\)下方的方格的个数记为\(\operatorname{ind}\gamma\)，将\((-1)^{\operatorname{ind}\gamma}\)称为\(\gamma\)的符号，记为\(\operatorname{sgn}\gamma\). 如果将\(\gamma\)视为映射的话，有</p> \[\operatorname{sgn}\gamma = (-1)^{\frac{q(q-1)}{2} + \sum_{i=1}^{p+q-1}y(i)}\] <h3 id="单纯形剖分">单纯形剖分</h3> <p>借助表格里的道路，我们可以定义两个奇异单形的乘积的单形剖分：</p> \[m(\sigma^{p}, \tau^{q}) = \sum_{\gamma \in \mathscr{P}(p,q)} \operatorname{sgn}\gamma \cdot (\sigma \times \tau)\circ [(e_{x(0)},e_{y(0)}), (e_{x(1)},e_{y(1)}), \dots, (e_{x(p+q)},e_{y(p+q)})]\] <p>其中\(\mathscr{P}(p,q)\)表示\(p\)列\(q\)行表格中的所有道路构成的集合。我们在这里不会严格证明这是一个单纯形剖分，只会给出一个直观的解释。</p> <p>比如我们来看道路：</p> \[\gamma_0:(0,0)\to (1,0)\to (2,0) \to \cdots \to (p,0) \to (p,1)\to \cdots \to (p,q)\] <p>这个道路给出的\(p+q\)维单形有\(p+q-1\)个面落在柱体\(\Delta^p \times \Delta^q\)的边界上，只有一个不在柱体的表面：</p> \[[(e_0,e_0),(e_1,e_0),\dots, (e_{p-1},e_{0}), (e_{p},e_1),(e_{p},e_2),\dots, (e_p,e_q)]\] <p>这个面实际上对应着\(\gamma_0\)在\((p,0)\)处的唯一一个“拐角”。为了消去这个面，我们将这个拐角“翻折”一下，得到新的路径\(\gamma_1\)：</p> \[\begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; &amp; (p,1) \\ &amp;&amp;&amp; \uparrow \\ \rightarrow &amp; (p-1,0) &amp; \rightarrow &amp; (p,0)\\ \hline \end{array} \leadsto \begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; \rightarrow &amp; (p,1) \\ &amp; \uparrow &amp;&amp;\\ \rightarrow &amp; (p-1,0) &amp;&amp; (p,0)\\ \hline \end{array}\] <p>为了让这个面的系数变为\(0\)，我们还需要给\(\gamma_1\)乘上一个负号（这时\(\gamma_1\)前的符号正好是\(\operatorname{sgn}\gamma_1\)）。</p> <p>但\(\gamma_1\)又会给出两个不在柱体边界上的面，这两个面正好对应\(\gamma_1\)在\((p-1,0)\)和\((p,1)\)处的两个拐角，所以为了消去这两个面，我们要将\(\gamma_1\)的两个“拐角”分别“翻折”，得到两条道路\(\gamma_2, \gamma_3\). 这时\(\gamma_2,\gamma_3\)前的符号会与\(\gamma_1\)的符号相反，所以它们的符号恰好也是\(\operatorname{sgn}\gamma_2\)和\(\operatorname{sgn}\gamma_3\).</p> <p>因为\(\gamma_2,\gamma_3\)也会有“拐角”，为了消去它们的拐角，我们需要再减去三条路径（这里有个微妙的地方是：有一条路径会同时抵消掉两个面，所以这条路径对应的系数仍然是\(\pm 1\)）。如此反复，我们就可以得到这一小节开头的单形剖分\(m(\sigma, \tau)\).</p> <h2 id="4性质与推论">4.性质与推论</h2> <p>对奇异单形的乘积有了单形剖分\(m\)之后，我们很容易将\(m\)延拓到奇异链的乘积上，得到：</p> \[m\colon S_p(X)\otimes S_q(Y) \longrightarrow S_{p+q}(X\times Y)\] <p>我们进一步给出单形剖分\(m\)的性质。</p> <p>首先很容易想到的是，两个标准单形\(\Delta^p, \Delta^q\)的乘积的边界是</p> \[(\partial \Delta^p)\times \Delta^q + (-1)^p \Delta^p \times (\partial\Delta^q)\] <p>而从上一节最后的论述可以看出来，单形剖分不改变乘积的边界，所以\(m(\sigma^{p},\tau^{q})\)的边界也是柱体\(\Delta^p\times\Delta^q\)的边界，也就是有：</p> \[\partial m(\sigma^p \otimes \tau^q) = m\bigl((\partial \sigma^p) \otimes \tau^q\bigr) + (-1)^{p}m\bigl(\sigma^p\otimes(\partial \tau^q)\bigr)\] <p>我们定义\(S_*(X),S_*(Y)\)的乘积复形为</p> \[\left(S_*(X)\otimes S_*(Y)\right)_{r} = \bigoplus_{p+q=r}S_p(X) \otimes S_q(Y)\] <p>其上的边缘算子为</p> \[\partial^{\otimes}\colon \sigma^p \otimes \tau^q \longmapsto (\partial \sigma^p) \otimes \tau^q + (-1)^{p}\sigma^p\otimes(\partial \tau^q)\] <p>另外很容易注意到的是，\(m\)是自然的，也就是，如果将\(S_{*}(\cdot)\otimes S_{*}(\cdot)\)与\(S_{*}(\cdot \times \cdot)\)视作两个函子，那么\(m\)实际上给出了它们之间的一个自然变换。</p> <p>那么这时候我们就知道：</p> <blockquote> <p><strong>命题</strong>：我们定义的单形剖分</p> \[m: S_*(X)\otimes S_*(Y) \rightarrow S_*(X\times Y)\] <p>是链映射，进而其诱导了同态：</p> \[m_*\colon H_r(S_*(X)\otimes S_*(Y)) \longrightarrow H_r(X \times Y).\] </blockquote> <p>如果使用一些同调代数的技术（比如谱序列），可以算出：</p> \[\begin{aligned} H_r(S_*(X)\otimes S_*(Y)) &amp; \sim \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \\ &amp; \sim \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \\ \end{aligned}\] <blockquote> <p><strong>推论</strong>：我们有自然的同态：</p> \[\begin{gathered} \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \longrightarrow H_r(X \times Y) \\ \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \longrightarrow H_r(X \times Y) \end{gathered}\] </blockquote> <p>在很多时候，上面的两个同构会给出一个同态，在此我们不讨论这一话题。</p> <h2 id="附录使用计算机计算低维奇异单形乘积的单形剖分">附录：使用计算机计算低维奇异单形乘积的单形剖分</h2> <p>在给出\(\sigma,\tau\)的具体维数的时候，可以使用计算机验证我们定义的\(m\)确为链映射。在此我们给出Python代码。</p> <pre><code class="language-Python">def select(n,p):
    '''An assistant function which return all the q-element subsets of [n] in the form: list(0 or 1). This can be further used to describe all the paths needed.'''
    if n&lt;=0 or p&lt;0 or n&lt;p:
        return []
    if p == 0:
        return [[0]*n]
    if n == p:
        return [[1,]*n]
    result = []
    l1 = select(n-1,p-1)
    for i in l1:
        i.append(1)
        result.append(i)
    l2 = select(n-1,p)
    for i in l2:
        i.append(0)
        result.append(i)
    return result

def path_generator(p:tuple,q:tuple)-&gt;list:
    '''generate the path needed to describe the simplex decomposition of product of 2 chains.'''
    r = len(p)+len(q)-2
    y = len(q)-1
    proto_path = select(r,len(q)-1)
    all_path = []
    for i in proto_path:
        path = []
        x_axis = 0
        y_axis = 0
        path_index = (-1)**(r*y+y*(y-1)//2)
        path.append((p[x_axis],q[y_axis]))
        for number_of_step in range(1,len(i)+1):
            x_axis += 1-i[number_of_step-1]
            y_axis += i[number_of_step-1]
            path.append((p[x_axis],q[y_axis]))
            path_index *= (-1)**(number_of_step*i[number_of_step-1])
        all_path.append((tuple(path),path_index))
    return all_path


class chain:
    '''class of (integer-coefficient simplicial) chain complexes'''

    def __init__(self, chains:dict =dict()):
        '''chains{simplex: coefficient} is a dictation record the simplexes and its coefficients in the chain.'''
        chains_keys = list(chains.keys())
        for i in chains_keys:
            if chains[i] == 0:
                chains.pop(i) # remove empty elements
        self.cells = chains
        return

    def __repr__(self):
        '''represent a chain as sum of "coefficient*simplex".'''
        if self.cells:
            return ' + '.join([str(self.cells[i])+str(i) for i in sorted(self.cells.keys())])
        else:
            return "0"

    def __add__(self, o):
        '''addition of chains.'''
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]+=o.cells[j]
            else:
                sum_chain[j] = o.cells[j]
        return chain(sum_chain)

    def __sub__(self, o):
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]-=o.cells[j]
            else:
                sum_chain[j] = -o.cells[j]
        return chain(sum_chain)

    def __mul__(self, o):
        '''Return the simplicial decomposition of Cartesian product of 2 chains.'''
        if type(o) == int or type(o) == float:
            for i in self.cells:
                self.cells[i] *= o
            return self
        else:
            d = dict()
            for i in self.cells:
                for j in o.cells:
                    for path in path_generator(i, j):
                        cell = path[0]
                        cell_index = path[1]
                        if cell in d.keys():
                            d[cell] += cell_index * self.cells[i]*o.cells[j]
                        else:
                            d[cell] = cell_index * self.cells[i]*o.cells[j]
            return chain(d)

    def partial(self):
        '''The boundary operator on chain complex.'''
        result = chain()
        for i in self.cells:
            d = dict()
            for j in range(len(i)):
                d[i[:j]+i[j+1:]] = (-1)**j*self.cells[i]
            result = result + chain(d)
        return result

if __name__ == "__main__":
    for p in range(1, 7):
        l = []
        for q in range(1,p+1):
            s1=tuple(i for i in range(p+1))
            s2=tuple(i for i in range(q+1))
            c1 = chain({s1:1})
            c2 = chain({s2:1})
            c3=(c1*c2).partial()
            c4=c1.partial()*c2 + c1*(c2.partial())*(-1)**p
            l.append(c3-c4)
        print(l)
</code></pre> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds/">Compact Lie Groups as Boundaries of Manifolds(In Chinese)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum%E7%9B%B4%E5%92%8C%E5%88%86%E8%A7%A3/">Deduction of Morse Inequality, Perfect Morse Function and Decomposition into Derict Sum(In Chinese)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Three-Ways-to-Think-of-Connections-on-Vector-Bundles/">Three Ways to Think of Connections on Vector Bundles(In Chinese)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Bounded-Operators-Can-Not-Satisfy-Canonical-Commutative-Relation/">Bounded Operators Can Not Satisfy Canonical Commutative Relation(In Chinese)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Initiation-to-Convergence-Theory/">Initiation to Convergence Theory(In Chinese)</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Yizhao Chen 陈轶钊. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: February 27, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>