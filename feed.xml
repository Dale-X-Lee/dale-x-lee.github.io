<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dale-x-lee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dale-x-lee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-09T14:05:04+00:00</updated><id>https://dale-x-lee.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Compact Lie Groups as Boundaries of Manifolds(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds/" rel="alternate" type="text/html" title="Compact Lie Groups as Boundaries of Manifolds(In Chinese)"/><published>2025-01-26T00:58:16+00:00</published><updated>2025-01-26T00:58:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds/"><![CDATA[<p>我们在这篇笔记里给出一个简单的构造：对任意一个紧李群\(G\)，我们给出一个具体的带边紧流形\(M\)，使得它的边界\(\partial M\)微分同胚于\(G\).</p> <h2 id="流形的构造">流形的构造</h2> <p>我们不加证明地使用下面的结果：</p> <blockquote> <p><strong>结论</strong>：对任意一个紧流形\(G\)，存在\(G\)真李子群\(H\)，使得</p> \[H \cong S^1\] <p>这里\(S^1\subset \mathbb{C}\)上的运算由\(\mathbb{C}\)上乘法诱导。</p> </blockquote> <p>我们这里不区分\(H\)和\(S^1\)，这样\(S^1\)在\(G\)上的右乘给出了\(G\)上的紧、自由\(S^1\)-右作用，这使得\(G\)成为了\(G/S^1\)上一个\(S^1\)-主丛：</p> \[\begin{matrix} S^1 &amp; \hookrightarrow &amp; G \\ &amp;&amp; \downarrow \\ &amp;&amp; G/S^1 \\ \end{matrix}\] <p>取\(S^1\)在\(\mathbb{C}\)上的表示\(\rho(e^{i\theta})z = e^{i\theta}z\). 这一表示定义了配从</p> \[E = G\times_{\rho} \mathbb{C} = \{[(g, z)]\mid g\in G, z\in \mathbb{C}\}\] <p>注意到\(\mathbb{C}\)上的标准内积是\(S^1\)-不变的，所以它诱导了向量丛\(E\)上的内积\(g(u,v)\)，于是可以得到\(E\)的单位球丛</p> \[B(E)= \{v\in E \mid g(v,v)\leqslant 1\} =\{[(g,z)]\in E \mid |z| \leqslant 1\}\] <p>其中最后一个等号用到了\(g\)的定义。我们说明\(B(E)\)的边界正好是\(G\).</p> <p>事实上，我们有</p> \[\begin{aligned} \partial \bigl(B(E)\bigr) &amp; = \{v\in E \mid g(v,v)=1\} \\ &amp; = \{[(g,z)]\mid z\in S^1\} \\ &amp; = G \times_{\rho}S^1 \end{aligned}\] <p>而容易看出\(G \times_{\rho} S^1\)和\(G\)微分同胚的（例如可由\(S^1\)-等变映射</p> \[\begin{matrix} m \colon &amp; G \times S^1 &amp; \longrightarrow &amp; G \\ &amp; (g,z) &amp; \longmapsto &amp; g\cdot z \\ \end{matrix}\] <p>诱导光滑映射</p> \[\begin{matrix} \tilde{m} \colon &amp; \partial \bigl(B(E)\bigr) &amp;\longrightarrow &amp; G \\ &amp; [(g,z)] &amp; \longmapsto &amp; g\cdot z \\ \end{matrix}\] <p>然后靠证明\(\tilde{m}\)的单的和切映射处处是线性同构来说明）。这样我们就完成了构造。</p> <h2 id="一个例子作为流形边界的三维实射影空间">一个例子：作为流形边界的三维实射影空间</h2> <p>对四元数\(\mathbb{H}\)上的球面</p> \[S^3 = \{x + yi+zj+wk \mid x^2+y^2+z^2+w^2=1\}\] <p>容易看出它在四元数乘法下封闭，并且可以证明，它可以保持内积地作用在</p> \[$\mathbb{R}^3=\{ui+vj+wk\mid u,v,w\in\mathbb{R}\}\] <p>上：</p> \[\alpha \cdot r := \alpha r \alpha^{-1},\quad \forall \alpha \in S^3, r\in \mathbb{R}^3\] <p>因此我们会得到李群同态：</p> \[S^3 \longrightarrow SO(3)\] <p>这一同态的核恰好为\(\pm 1\)，所以我们会有微分同胚：</p> \[\mathbb{R}P^3 \cong S^3/\{\pm 1\} \cong SO(3)\] <p>这样三维实射影空间\(\mathbb{R}P^3\)会是某个流形的边界。我们在这里给出一个更加具体的构造。</p> <p>我们取\(S^2\)的切空间</p> \[TS^3 = \{(x,v)\mid x,v\in\mathbb{R}^3, x\cdot x = 1, x\cdot v = 0\}\] <p>它的单位球丛是：</p> \[N = \{(x,v) \in \mathbb{R}^3\times \mathbb{R}^3 \mid x\cdot v = 0, x\cdot x = 1, v\cdot v \leqslant 1\}\] <p>这时有：</p> \[\mathbb{R}P^3 \cong \partial N\] <p>事实上，这个同胚可由下面的的映射给出：</p> \[\partial N \ni (x,v) \longmapsto (x,v,x\times v) \in SO(3) \cong \mathbb{R}P^3\] <p>其中我们将\(\mathbb{R}^3\)中元素视为列向量，\(x\times v\)表示两个向量的叉乘。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[A constructive proof that every Lie group is the boundary of certain smooth manifold.]]></summary></entry><entry><title type="html">Deduction of Morse Inequality, Perfect Morse Function and Decomposition into Derict Sum(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum/" rel="alternate" type="text/html" title="Deduction of Morse Inequality, Perfect Morse Function and Decomposition into Derict Sum(In Chinese)"/><published>2024-10-20T14:30:16+00:00</published><updated>2024-10-20T14:30:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum/"><![CDATA[<h2 id="摘要">摘要</h2> <p>本文会给出Morse-Bott函数对应的Morse不等式的推导，并由此从代数的角度给出一个Morse-Bott函数是完美的(perfect)的充要条件。我们在推导中假定，下水平集在越过临界点时拓扑上的变化是已经熟知的结论。</p> <h2 id="定义与主定理">定义与主定理</h2> <p>Morse理论的大致想法是：通过空间\(M\)上一个“足够好”的函数\(f\)（这样的函数通常被叫做Morse-Bott函数）的临界点来描述空间\(M\)本身的拓扑性质。具体来说，Morse理论中的空间指的是紧致微分流形；一个函数\(f\)需要满足下面两点才能被叫做“足够好”：</p> <ul> <li>函数\(f\)的临界点集\(C_f\)的每个连通分支\(C_i\)都是一个子流形。</li> <li>函数\(f\)在任意一个临界点\(p \in C_i\)处的“Hessian矩阵”限制在\(C_i\)的法丛上非退化。</li> </ul> <p>我们再引入一些定义。</p> <p>对临界点集的每个联通分支\(C_i\)，将\(f\)在\(C_i\)上的Hessian矩阵的负惯性指数称为\(C_i\)的指标，一般用\(\lambda_{C_i}\)来表示。更进一步，在选定了一个黎曼度量之后，可以定义出\(C_i\)的法丛\(\nu_{C_i}\)，根据\(f\)的Hessian矩阵的特征值的正负，我们可以将法丛\(\nu_{C_i}\)进一步分解成两部分：</p> \[\nu_{C_i} = \nu_{C_i}^+ \oplus \nu_{C_i}^-\] <p>并用\(\theta^{\pm}\)表示由\(\nu_{C_i}^{\pm}\)的定向给出的纤维丛。</p> <p>对于任意一个拓扑空间\(X\)和主理想整环\(R\)，我们可以定义一个无穷形式幂级数\(P_t(X; R) \in \mathbb{Z}[[t]]\)，它的\(k\)次项系数正好是第\(k\)个\(R\)系数约化奇异上同调群关于\(R\)的秩，也就是</p> \[P_t(X; R) = \sum_{k \geq 0}\mathrm{rank}_R\left(H^k(X; R)\right)\cdot t^k\] <p>这个多项式被称作空间\(X\)的Poincaré多项式。我们后面只会使用到\(R\)为整数环\(\mathbb{Z}\)或\(\mathbb{Q}\)的某个扩域的情形。在不引发歧义的情况下，我们会将Poincaré多项式简记为\(P_t(X)\). 在此基础上，我们可以定义一个Morse-Bott函数\(f\)的Morse多项式</p> \[\mathfrak{M}_t(f; R) := \sum_{C_i} t^{\lambda_{C_i}}P_t(C_i; \theta^-\otimes R)\] <p>这里的求和是对临界点集\(C_f\)的全体连通分支\(C_i\)求和。</p> <p>在这些定义的基础上，我们可以陈述Morse理论的一个主要结果：</p> <blockquote> <p>对紧致流形\(M\)和其上的Morse-Bott函数\(f\)，如果设\(f\)的临界点的连通分支为\(C_1, C_2, \dots, C_N\)，那么存在一个以非负整数为系数的无穷形式幂级数\(R(t)\)，使得\(f\)的Morse多项式和\(M\)的Poincaré多项式的差正好是\((1+t)R(t)\)，也就是</p> \[\mathfrak{M}_t(f;R)-P_t(M; R) = (1+t)R(t)\] <p>这里\(R\)是整数环\(\mathbb{Z}\)或有理数域\(\mathbb{Q}\)的扩域。</p> </blockquote> <p>这被称作Morse不等式，是本文的主定理。</p> <h2 id="主定理的证明">主定理的证明</h2> <p>为了后面叙述的方便，我们再引入一些定义。</p> <p>对于一个函数\(f: M \rightarrow \mathbb{R}\)，将集合\(f^{-1}(-\infty, a)\)称作\(f\)的下水平集，记作\(M^a\).</p> <p>我们的证明需要用到下面的引理：</p> <blockquote> <p>对紧致流形\(M\)和其上的Morse-Bott函数\(f\)：</p> <p>(1)如果\(f\)在\([a, b]\)中无临界值，那么\(M^b\)与\(M^a\)同伦等价。</p> <p>(2) 如果\(f\)在区间\([a, b]\)的临界值只有\(c_0 \in (a, b)\)，设\(C\)是取值为\(c_0\)的那些临界点，那么有空间的同伦等价：</p> \[M^b \sim M^a \cup_{\phi} \nu_{C}^-\] <p>这里\(\phi: \partial \nu_{C}^- \rightarrow M^a\)是一个光滑映射。</p> </blockquote> <p>我们略去引理的证明。</p> <p>因为流形是紧致的，所以我们可以构造一列下水平集</p> \[\emptyset \subset \cdots \subset M^{a} \subset M^{b} \subset M^c \subset \cdots \subset M\] <p>使得任何两个相邻下水平集之间只有一个\(f\)的临界值。我们希望对这一列下水平集归纳地证明</p> \[\mathfrak{M}_t(f\vert _{M^a};R)-P_t(M^a; R) = (1+t)R_a(t)\] <p>其中\(f\vert _{M^a}\)表示\(f\)在\(M^a\)上的限制。归纳的奠基是容易的，我们主要看如何从\(M^a\)上的等式到\(M^b\)上的等式。</p> <p>对两个相邻的下水平集\(M^a \subset M^b\)，设其间的临界点集为\(C\). 通过对\(f\)作微扰，我们可以不妨假定\(C\)是连通的。为了展示证明的主要想法，我们进一步假设\(\nu_C^-\)是可定向向量丛。这一节最后的注记解释了处理不可定向的情况的方法。</p> <p>首先，空间对\((M^b, M^a)\)诱导了长正合列：</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^k(M^b, M^a) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>利用引理以及Thom同构，我们知道\(H^k(M^b, M^a)\)和\(H^{k-\lambda_C}(C)\)同构。因此上面的长正合列变成了：</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>我们来看长正合列中的每个映射，它们给出了一系列短正合列：</p> \[0 \rightarrow \ker i^*_k \rightarrow H^k(M^b) \rightarrow \mathrm{im}\ i^*_k \rightarrow 0\] \[0 \rightarrow \ker q^*_k \rightarrow H^{k-\lambda_C}(C) \rightarrow \mathrm{im}\ q^*_k \rightarrow 0\] \[0 \rightarrow \ker \delta^*_k \rightarrow H^k(M^a) \rightarrow \mathrm{im}\ \delta^*_k \rightarrow 0 \\\] <p>进而可以得到等式：</p> \[\begin{matrix} \mathrm{rank}\left(\ker i^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ i^*_k \right) &amp;=&amp; \mathrm{rank}\left(H^k(M^b) \right) \\ \mathrm{rank}\left(H^{k-\lambda_C}(C) \right) &amp;=&amp;\mathrm{rank}\left(\ker q^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ q^*_k\right) \\ \mathrm{rank}\left(H^k(M^a) \right) &amp;=&amp; \mathrm{rank}\left(\ker \delta^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) \\ \end{matrix}\] <p>将上面三个等式相加，并利用长正合列将所有的“\(\ker\)”都替换为“\(\mathrm{im}\)”后得到：</p> \[\begin{aligned} &amp;\mathrm{rank}\left(H^{k - \lambda_C}(C) \right) - \Bigl(\mathrm{rank}\left(H^k(M^b) \right) - \mathrm{rank}\left(H^k(M^a) \right) \Bigr) \\ &amp; =\mathrm{rank}\left(\mathrm{im}\ \delta^*_{k-1} \right) + \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) \end{aligned}\] <p>在上面的等式两边同时乘以\(t^k\)，并对\(k\)求和就得到：</p> \[t^{\lambda_C} P_t(C)-\left(P_t(M^b) - P_t(M^a)\right) = (1+t)R_C(t)\] <p>其中\(R_C(t) = \sum_{k \geq 0} t^k \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right)\)是一个非负整数系数的形式幂级数。因为\(C\)是\(M^a\)与\(M^b\)之间唯一的临界点集，所以\(t^{\lambda_C}P_t(C)\)就是\(f\vert _{M^b}\)的Morse多项式和\(f\vert _{M^a}\)的Morse多项式的差，进而上面的等式可以写成</p> \[\begin{aligned} &amp;\mathfrak{M}_t(f\vert _{M^b};R)-P_t(M^b; R)\\ &amp; = \bigl(\mathfrak{M}_t(f\vert _{M^a};R)-P_t(M^a; R)\bigr) + (1+t)R_C(t)\\ \end{aligned}\] <p>利用这一等式，我们可以很轻松地完成归纳。</p> <h3 id="注记">注记</h3> <p>有读者会注意到，我们在定义Morse多项式时，用到了向量丛\(\nu_C^-\)的定向丛\(\theta^-\)，但证明中却没有出现这一纤维丛，这是因为我们在证明中假定了向量丛\(\nu_C^-\)是可定向的。在不可定向的时候，我们需要用到twisted-Thom同构：</p> \[H^*(\nu_C^-, \partial \nu_C^-; R) \cong H^{* - \lambda_C}(C; \theta^- \otimes R)\] <p>这时候就会出现\(\nu_C^-\)的定向丛\(\theta^-\).</p> <p>在系数环\(R\)是实数域\(\mathbb{R}\)的时候，可以在Bott和Tu所著的书<em>Differential Forms in Algebraic Topology</em>中第一章最后一节找到这一同构的证明。</p> <h2 id="完美morse函数">完美Morse函数</h2> <p>我们称一个Morse-Bott函数\(f: M \rightarrow \mathbb{R}\)是完美的(perfect)，如果它的Morse多项式正好等于\(M\)的Poincaré多项式。</p> <p>根据上面的证明，我们知道，一个Morse-Bott函数\(f\)是完美的当且仅当对每个临界点集\(C\)，我们定义的多项式\(R_C(t)\)等于0. 这可以总结为下面的结论：</p> <blockquote> <p>以下几个命题彼此等价：</p> <p>(1)一个函数\(f: M \rightarrow \mathbb{R}\)是完美的Morse-Bott函数</p> <p>(2)对临界点集的每个连通分支\(C\)和长正合列</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>中的映射\(\delta^*_k\)，有\(\mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) = 0\).</p> <p>(3)对每个\(k\)，上面长正合列中的映射\(\delta^*_k\)的像集由挠元素构成。</p> </blockquote> <p>当上同调的系数环被选取为有理数域\(\mathbb{Q}\)或者它的扩域时，上同调环始终是无挠的，所以我们得到了：</p> <blockquote> <p>在有理数域的扩域中，以下结论彼此等价：</p> <p>(1)一个函数\(f: M \rightarrow \mathbb{R}\)是完美的Morse-Bott函数</p> <p>(2)对临界点集的每个连通分支\(C\)和长正合列</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>中的每个映射\(\delta^*_k\)，它的像是\(0\).</p> <p>(3)上面的长正合列可以分裂为短正合列</p> \[0 \rightarrow H^{*-\lambda_C}(C) \xrightarrow{q^*} H^*(M^b) \xrightarrow{i^*} H^*(M^a) \rightarrow 0\] </blockquote> <p>注意到域系数的短正合列一定是分裂的，所以如果一个Morse函数\(f\)是完美的，下水平集每跨过一个临界点的一个连通分支，我们就能得到一个直和分解</p> \[H^*(M^b) \cong H^{*-\lambda_C}(C)\oplus H^*(M^a)\] <p>进而可以知道，我们有直和分解：</p> \[H^*(M) \cong \bigoplus_{C_i} H^{*-\lambda_{C_i}}(C_i)\] <p>这个等式相当于说，一个流形上的完美的Morse-Bott函数的临界点集几乎确定了这个流形的域系数上同调群。这里使用“几乎”是因为，上面的同构并不是典范的，这个同构依赖于归纳过程中将\(M^a\)的上同调群嵌入到\(M^b\)的上同调群的方式。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Some notes when learning Morse theory for the second time.]]></summary></entry><entry><title type="html">Simplex Decomposition of Product of Singular Simplexes(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes/" rel="alternate" type="text/html" title="Simplex Decomposition of Product of Singular Simplexes(In Chinese)"/><published>2024-10-17T23:57:16+00:00</published><updated>2024-10-17T23:57:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes/"><![CDATA[<h2 id="1引入">1.引入</h2> <p>在同调论里，一个很自然的问题是，对于两个拓扑空间\(X,Y\)，它们的乘积\(X\times Y\)的奇异同调群如何用各自的奇异同调群表示。</p> <p>这一问题相当基本，答案看起来也相当明显：我们希望有</p> \[H_*(X\times Y) \cong H_*(X)\otimes H_*(Y).\] <p>不过在试图计算的时候，得到上面的关系会相当麻烦。一个主要的原因是，两个奇异单形的乘积不再是奇异单形。</p> <p>为了让我们的计算能够进行下去，一个办法就是对两个奇异单形\(\sigma, \tau\)的乘积\(\sigma \times \tau\)作单形剖分。依据Gelfand的<em>Methods of Homoligical Algebra</em>，我们这里提供一个剖分的办法（但不会给出证明）。</p> <h2 id="2一些记号">2.一些记号</h2> <p>我们在这一节里介绍之后使用的符号。</p> <ul> <li>\(e_{i-1}\)：\(\mathbb{R}^n(n\geq i)\)中的基向量，也就是第\(i\)个分量为\(1\)，余下分量为\(0\)的向量。因为在每个向量末尾添上\(0\)，可以将\(\mathbb{R}^n\)自然地嵌入到\(\mathbb{R}^{n+1}\)，所以我们后面认为\(e_i\)落在一个维数充分大的向量空间里。</li> <li>\(\Delta^q\)：\(q\)维标准单形，即</li> </ul> \[\{ \sum_{i=0}^q x_i e_i \mid 0\leqslant x_i \leqslant 1, \sum_{i}x_i =1 \}\] <ul> <li>\(\sigma\colon \Delta^p \rightarrow X\)：这是\(X\)中的一个奇异单形，有时我们会用上标来表示\(\sigma\)的维数，即\(\sigma^p\)表明\(\sigma\)是一个\(p\)维单形。</li> <li>\([v_0,v_1, \dots, v_q], v_i \in V\)：表示线性空间\(V\)中的奇异单形：</li> </ul> \[\begin{aligned} \Delta^q &amp; \longrightarrow V \\ \sum_{i=0}^q x_ie_i &amp; \longmapsto \sum_{i=0}^q x_i v_i \end{aligned}\] <ul> <li>\([n]\)：表示集合\(\{0,1,2,\dots, n\}\).</li> </ul> <h2 id="3奇异单形的乘积的单形剖分">3.奇异单形的乘积的单形剖分</h2> <p>我们接下来描述两个奇异单形\(\sigma: \Delta^p \rightarrow X,\tau: \Delta^q \rightarrow Y\)的乘积：</p> \[\sigma \times \tau \colon \Delta^p \times \Delta^q \longrightarrow X \times Y\] <p>的单形剖分：</p> \[m(\sigma, \tau) \in S_{p+q}(X\times Y)\] <h3 id="表格里的路径">表格里的路径</h3> <p>我们将集合\([p]\times [q]\)看作一个\(p\)列、\(q\)行的表格的顶点，每个顶点的横坐标的取值范围为\(0,1,\dots, p\)，纵坐标的取值范围为\(0,1,\dots, q\). 并且表格左下角的顶点为\((0,0)\)，右上角的顶点为\((p,q)\).</p> \[\begin{array}{|l|l|l|l|l|l|} \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \end{array}\] <p>我们从\((0,0)\)出发，每次向上或者向右走一格，一直走到顶点\((p,q)\)，就会得到这个表格中的路径。严格来说，表格里的路径是一个映射：</p> \[\begin{aligned} \gamma\colon [p+q] &amp; \longrightarrow [p]\times [q]. \\ i &amp; \longmapsto \bigl(x(i),y(i)\bigr) \end{aligned}\] <p>满足：</p> \[\begin{gathered} \gamma(0)=(0,0), \ \gamma(p+q)=(p,q)\\ \gamma(i)-\gamma(i-1) \in \{(0,1), (1,0)\}, \forall 1\leqslant i \leqslant p+q.\\ \end{gathered}\] <p>我们将位于\(\gamma\)下方的方格的个数记为\(\operatorname{ind}\gamma\)，将\((-1)^{\operatorname{ind}\gamma}\)称为\(\gamma\)的符号，记为\(\operatorname{sgn}\gamma\). 如果将\(\gamma\)视为映射的话，有</p> \[\operatorname{sgn}\gamma = (-1)^{\frac{q(q-1)}{2} + \sum_{i=1}^{p+q-1}y(i)}\] <h3 id="单纯形剖分">单纯形剖分</h3> <p>借助表格里的道路，我们可以定义两个奇异单形的乘积的单形剖分：</p> \[m(\sigma^{p}, \tau^{q}) = \sum_{\gamma \in \mathscr{P}(p,q)} \operatorname{sgn}\gamma \cdot (\sigma \times \tau)\circ [(e_{x(0)},e_{y(0)}), (e_{x(1)},e_{y(1)}), \dots, (e_{x(p+q)},e_{y(p+q)})]\] <p>其中\(\mathscr{P}(p,q)\)表示\(p\)列\(q\)行表格中的所有道路构成的集合。我们在这里不会严格证明这是一个单纯形剖分，只会给出一个直观的解释。</p> <p>比如我们来看道路：</p> \[\gamma_0:(0,0)\to (1,0)\to (2,0) \to \cdots \to (p,0) \to (p,1)\to \cdots \to (p,q)\] <p>这个道路给出的\(p+q\)维单形有\(p+q-1\)个面落在柱体\(\Delta^p \times \Delta^q\)的边界上，只有一个不在柱体的表面：</p> \[[(e_0,e_0),(e_1,e_0),\dots, (e_{p-1},e_{0}), (e_{p},e_1),(e_{p},e_2),\dots, (e_p,e_q)]\] <p>这个面实际上对应着\(\gamma_0\)在\((p,0)\)处的唯一一个“拐角”。为了消去这个面，我们将这个拐角“翻折”一下，得到新的路径\(\gamma_1\)：</p> \[\begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; &amp; (p,1) \\ &amp;&amp;&amp; \uparrow \\ \rightarrow &amp; (p-1,0) &amp; \rightarrow &amp; (p,0)\\ \hline \end{array} \leadsto \begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; \rightarrow &amp; (p,1) \\ &amp; \uparrow &amp;&amp;\\ \rightarrow &amp; (p-1,0) &amp;&amp; (p,0)\\ \hline \end{array}\] <p>为了让这个面的系数变为\(0\)，我们还需要给\(\gamma_1\)乘上一个负号（这时\(\gamma_1\)前的符号正好是\(\operatorname{sgn}\gamma_1\)）。</p> <p>但\(\gamma_1\)又会给出两个不在柱体边界上的面，这两个面正好对应\(\gamma_1\)在\((p-1,0)\)和\((p,1)\)处的两个拐角，所以为了消去这两个面，我们要将\(\gamma_1\)的两个“拐角”分别“翻折”，得到两条道路\(\gamma_2, \gamma_3\). 这时\(\gamma_2,\gamma_3\)前的符号会与\(\gamma_1\)的符号相反，所以它们的符号恰好也是\(\operatorname{sgn}\gamma_2\)和\(\operatorname{sgn}\gamma_3\).</p> <p>因为\(\gamma_2,\gamma_3\)也会有“拐角”，为了消去它们的拐角，我们需要再减去三条路径（这里有个微妙的地方是：有一条路径会同时抵消掉两个面，所以这条路径对应的系数仍然是\(\pm 1\)）。如此反复，我们就可以得到这一小节开头的单形剖分\(m(\sigma, \tau)\).</p> <h2 id="4性质与推论">4.性质与推论</h2> <p>对奇异单形的乘积有了单形剖分\(m\)之后，我们很容易将\(m\)延拓到奇异链的乘积上，得到：</p> \[m\colon S_p(X)\otimes S_q(Y) \longrightarrow S_{p+q}(X\times Y)\] <p>我们进一步给出单形剖分\(m\)的性质。</p> <p>首先很容易想到的是，两个标准单形\(\Delta^p, \Delta^q\)的乘积的边界是</p> \[(\partial \Delta^p)\times \Delta^q + (-1)^p \Delta^p \times (\partial\Delta^q)\] <p>而从上一节最后的论述可以看出来，单形剖分不改变乘积的边界，所以\(m(\sigma^{p},\tau^{q})\)的边界也是柱体\(\Delta^p\times\Delta^q\)的边界，也就是有：</p> \[\partial m(\sigma^p \otimes \tau^q) = m\bigl((\partial \sigma^p) \otimes \tau^q\bigr) + (-1)^{p}m\bigl(\sigma^p\otimes(\partial \tau^q)\bigr)\] <p>我们定义\(S_*(X),S_*(Y)\)的乘积复形为</p> \[\left(S_*(X)\otimes S_*(Y)\right)_{r} = \bigoplus_{p+q=r}S_p(X) \otimes S_q(Y)\] <p>其上的边缘算子为</p> \[\partial^{\otimes}\colon \sigma^p \otimes \tau^q \longmapsto (\partial \sigma^p) \otimes \tau^q + (-1)^{p}\sigma^p\otimes(\partial \tau^q)\] <p>另外很容易注意到的是，\(m\)是自然的，也就是，如果将\(S_{*}(\cdot)\otimes S_{*}(\cdot)\)与\(S_{*}(\cdot \times \cdot)\)视作两个函子，那么\(m\)实际上给出了它们之间的一个自然变换。</p> <p>那么这时候我们就知道：</p> <blockquote> <p><strong>命题</strong>：我们定义的单形剖分</p> \[m: S_*(X)\otimes S_*(Y) \rightarrow S_*(X\times Y)\] <p>是链映射，进而其诱导了同态：</p> \[m_*\colon H_r(S_*(X)\otimes S_*(Y)) \longrightarrow H_r(X \times Y).\] </blockquote> <p>如果使用一些同调代数的技术（比如谱序列），可以算出：</p> \[\begin{aligned} H_r(S_*(X)\otimes S_*(Y)) &amp; \sim \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \\ &amp; \sim \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \\ \end{aligned}\] <blockquote> <p><strong>推论</strong>：我们有自然的同态：</p> \[\begin{gathered} \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \longrightarrow H_r(X \times Y) \\ \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \longrightarrow H_r(X \times Y) \end{gathered}\] </blockquote> <p>在很多时候，上面的两个同构会给出一个同态，在此我们不讨论这一话题。</p> <h2 id="附录使用计算机计算低维奇异单形乘积的单形剖分">附录：使用计算机计算低维奇异单形乘积的单形剖分</h2> <p>在给出\(\sigma,\tau\)的具体维数的时候，可以使用计算机验证我们定义的\(m\)确为链映射。在此我们给出Python代码。</p> <pre><code class="language-Python">def select(n,p):
    '''An assistant function which return all the q-element subsets of [n] in the form: list(0 or 1). This can be further used to describe all the paths needed.'''
    if n&lt;=0 or p&lt;0 or n&lt;p:
        return []
    if p == 0:
        return [[0]*n]
    if n == p:
        return [[1,]*n]
    result = []
    l1 = select(n-1,p-1)
    for i in l1:
        i.append(1)
        result.append(i)
    l2 = select(n-1,p)
    for i in l2:
        i.append(0)
        result.append(i)
    return result

def path_generator(p:tuple,q:tuple)-&gt;list:
    '''generate the path needed to describe the simplex decomposition of product of 2 chains.'''
    r = len(p)+len(q)-2
    y = len(q)-1
    proto_path = select(r,len(q)-1)
    all_path = []
    for i in proto_path:
        path = []
        x_axis = 0
        y_axis = 0
        path_index = (-1)**(r*y+y*(y-1)//2)
        path.append((p[x_axis],q[y_axis]))
        for number_of_step in range(1,len(i)+1):
            x_axis += 1-i[number_of_step-1]
            y_axis += i[number_of_step-1]
            path.append((p[x_axis],q[y_axis]))
            path_index *= (-1)**(number_of_step*i[number_of_step-1])
        all_path.append((tuple(path),path_index))
    return all_path


class chain:
    '''class of (integer-coefficient simplicial) chain complexes'''

    def __init__(self, chains:dict =dict()):
        '''chains{simplex: coefficient} is a dictation record the simplexes and its coefficients in the chain.'''
        chains_keys = list(chains.keys())
        for i in chains_keys:
            if chains[i] == 0:
                chains.pop(i) # remove empty elements
        self.cells = chains
        return

    def __repr__(self):
        '''represent a chain as sum of "coefficient*simplex".'''
        if self.cells:
            return ' + '.join([str(self.cells[i])+str(i) for i in sorted(self.cells.keys())])
        else:
            return "0"

    def __add__(self, o):
        '''addition of chains.'''
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]+=o.cells[j]
            else:
                sum_chain[j] = o.cells[j]
        return chain(sum_chain)

    def __sub__(self, o):
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]-=o.cells[j]
            else:
                sum_chain[j] = -o.cells[j]
        return chain(sum_chain)

    def __mul__(self, o):
        '''Return the simplicial decomposition of Cartesian product of 2 chains.'''
        if type(o) == int or type(o) == float:
            for i in self.cells:
                self.cells[i] *= o
            return self
        else:
            d = dict()
            for i in self.cells:
                for j in o.cells:
                    for path in path_generator(i, j):
                        cell = path[0]
                        cell_index = path[1]
                        if cell in d.keys():
                            d[cell] += cell_index * self.cells[i]*o.cells[j]
                        else:
                            d[cell] = cell_index * self.cells[i]*o.cells[j]
            return chain(d)

    def partial(self):
        '''The boundary operator on chain complex.'''
        result = chain()
        for i in self.cells:
            d = dict()
            for j in range(len(i)):
                d[i[:j]+i[j+1:]] = (-1)**j*self.cells[i]
            result = result + chain(d)
        return result

if __name__ == "__main__":
    for p in range(1, 7):
        l = []
        for q in range(1,p+1):
            s1=tuple(i for i in range(p+1))
            s2=tuple(i for i in range(q+1))
            c1 = chain({s1:1})
            c2 = chain({s2:1})
            c3=(c1*c2).partial()
            c4=c1.partial()*c2 + c1*(c2.partial())*(-1)**p
            l.append(c3-c4)
        print(l)
</code></pre>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Construct a concrete simplex decomposition of product of singular simplexes with an intuitive proof.]]></summary></entry><entry><title type="html">Three Ways to Think of Connections on Vector Bundles(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Three-Ways-to-Think-of-Connections-on-Vector-Bundles/" rel="alternate" type="text/html" title="Three Ways to Think of Connections on Vector Bundles(In Chinese)"/><published>2024-10-05T21:30:16+00:00</published><updated>2024-10-05T21:30:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Three-Ways-to-Think-of-Connections-on-Vector-Bundles</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Three-Ways-to-Think-of-Connections-on-Vector-Bundles/"><![CDATA[<h2 id="摘要">摘要</h2> <p>向量丛上的联络（或协变导数）是几何学里一个基本的概念。这篇文章的主要目的是罗列理解联络的三种方式：视作局部的联络1-形式、视作平行移动、视作向量丛切空间的直和分解。并叙述主丛上的联络如何与这三种看法关联起来。本文不适合用作初次学习联络的资料，更适合已经了解过联络定义和基本性质的读者。</p> <h3 id="一些记号">一些记号</h3> <p>对于一个向量丛\(\pi: E \rightarrow M\)，和\(M\)中任意一点\(x\)，用\(E_x\)表示\(E\)在\(x\)处的纤维，对\(E\)的截面\(\xi: M \rightarrow E\)，用\(\xi_x\)表示\(\xi\)在\(x \in M\)处的值。</p> <h2 id="1-向量丛上的联络">1. 向量丛上的联络</h2> <p>几何学里，一个向量丛\(E\)上的联络\(\nabla\)有一个形式的定义：</p> <blockquote> <p><strong>定义</strong>：一个向量丛\(\pi: E \rightarrow M\)上的联络是一个实线性映射</p> \[\nabla: \Gamma(TM) \times \Gamma(E) \rightarrow \Gamma(E)\] <p>使得对任意的光滑函数\(f\in C^{\infty}(M)\)、向量场\(v \in \Gamma(TM)\)和向量丛的截面\(\xi \in \Gamma(E)\)，有</p> <ul> <li>\(\nabla_{fv} \xi = f \nabla_v\xi\).</li> <li>\(\nabla_v(f\xi) = v(f)\cdot\xi + f\nabla_v \xi\).</li> </ul> <p>这里\(\Gamma(F)\)表示由向量丛\(F\)的全体光滑截面构成的集合。</p> </blockquote> <p>这种定义虽然简单清楚，但我认为不够直观。接下来的三种解释方式从不同的角度说明了这一定义对应的几何直观。</p> <h3 id="11-联络1-形式omega">1.1. 联络1-形式\(\omega\)</h3> <p>联络1-形式提供了一种表示和计算联络的方便的方法。我们在选取了向量丛在\(U \subset M\)上的一组局部标架\(\xi_1, \xi_2, \dots, \xi_r\)之后，\(E\)的截面\(\xi\)可以表示成\(\xi_1, \dots, \xi_r\)的线性组合：</p> \[\xi = s^i \xi_i\] <p>这里\(s^i: U \rightarrow \mathbb{R}\)是\(U\)上的光滑函数。利用联络的定义可以算出：</p> \[\nabla \xi = \mathrm{d}s^i \otimes \xi_i + s^i \nabla \xi_i\] <p>注意到\(\nabla_v\xi_i\)可以写成\(\omega_i^{\ j}(v)\xi_j\)的形式，这里\(\omega_i^{\ j}\)是\(M\)上的1-形式，所以我们的联络进一步可以写成：</p> \[\nabla \xi = \mathrm{d}s^i \otimes \xi_i + s^i \omega_i^{\ j}\otimes \xi_j\] <p>很多时候上面的式子会被简写为\(\nabla = \mathrm{d} + \omega\)，这里\(\omega = (\omega_i^{\ j})_{n \times n}\)被称作联络1-形式。</p> <p>这里的联络1-形式依赖于局部标架的选取。如果我们选取了另一组标架\(\tilde{\xi}_1, \dots, \tilde{\xi}_r\)，这两个标架之间的关系可以用一个取值为可逆矩阵的光滑函数\(A\)来描述：</p> \[(\tilde{\xi}_1, \tilde{\xi}_2, \dots, \tilde{\xi}_r) = (\xi_1, \xi_2, \dots, \xi_r)\cdot A\] <p>这里的乘法是驻点的矩阵乘法。那么由标架\(\tilde{\xi}_1, \dots, \tilde{\xi}_r\)给出的联络1-形式\(\tilde{\omega}\)可以被表示为：</p> \[\tilde{\omega} = A^{-1}\omega A + A^{-1}\mathrm{d}A\] <p>反之，如果对\(E\)的每个局部平凡化都可以定义一个1-形式矩阵\(\omega\)，且不同平凡化之间的1-形式矩阵满足上面的变换关系，我们就能得到一个联络。</p> <p>联络1-形式的好处是，利用它可以迅速地算出一些重要的几何量，如联络\(\nabla\)的曲率可以表示成：</p> \[\Omega = \mathrm{d} \omega - \omega \wedge \omega\] <h3 id="12-沿着曲线的平行移动">1.2. 沿着曲线的平行移动</h3> <p>在定义了联络\(\nabla\)之后，我们可以定义平行向量场：一个沿着曲线\(\gamma\)的向量场\(\xi\)被称作与\(\gamma\)平行，如果\(\xi\)沿着\(\gamma\)的协变导数等于0，也就是</p> \[\nabla_{\dot{\gamma}(t)} \xi = 0\] <p>这里\(\dot{\gamma}\)表示\(\gamma\)的切向量。</p> <p>利用前面给出的联络1-形式的局部表示，我们知道，一个向量场平行于一条曲线相当于它的分量满足一个一阶的常微分方程。所以利用常微分方程解的存在唯一性理论可以知道，对给定的曲线\(\gamma\)和初值\(\xi_0 \in E_{\gamma(0)}\)，存在唯一一个初值为\(\xi_0\)的、平行于曲线\(\gamma\)的向量场\(\xi(t; \gamma,\xi_0)\). 更进一步，这个向量场光滑地依赖初值\(\xi_0\).</p> <p>当固定时间\(t\)，改变初值\(\xi_0\)时，我们会得到一个将\(\gamma(0)\)处的纤维\(E_{\gamma(0)}\)映到\(\gamma(t)\)处的纤维\(E_{\gamma(t)}\)的映射</p> \[\mathscr{P}_\gamma^{0 \to t}: E_{\gamma(0)} \rightarrow E_{\gamma(t)}\] <p>这个映射被叫做沿着\(\gamma\)的平行移动。一般地，我们用同样的方法可以定义从\(\gamma(a)\)到\(\gamma(b)\)的平行移动\(\mathscr{P}_{\gamma}^{a \to b}: E_{\gamma(a)} \rightarrow E_{\gamma(b)}\).</p> <p>平行移动的几何意义是相对直观的：它告诉了我们如何将一点处的纤维沿着一条曲线“不变地”移动到另一点处。事实上，\(\nabla\)能够被叫做“联络”的一个重要原因就是它定义的平行移动告诉了将不同点处的纤维联系了起来。</p> <p>尽管我们是利用联络定义的平行移动，但在仅知道平行移动的情况下，我们可以重新计算出联络，也就是下面的等式：</p> \[\nabla_{\dot{\gamma}(0)}\xi = \lim_{t \to 0} \frac{\mathscr{P}_\gamma^{t \to 0}\xi_{\gamma(t)} - \xi_{\gamma(0)}}{t}\] <p>在这个意义上，联络和平行移动是等价的。</p> <h3 id="13-向量丛切丛的直和分解">1.3. 向量丛切丛的直和分解</h3> <p>这一种理解方式来自于构造向量丛截面的“导数”。对于向量丛\(E\)的一个截面\(\xi: M \rightarrow E\)，它的切映射很自然地定义了一个导数：</p> \[\mathrm{D}\xi: TM \rightarrow TE\] <p>但我们期望一个截面在求导之后得到的是另一个截面，所以我们采取的办法是：将\(TE\)中的点\(w \in T_\xi E\)投影到\(TE\)沿着纤维方向的切空间\(T_\xi(E_{\pi(\xi)})\)上，注意到\(E_{\pi(\xi)}\)是线性空间，所以\(T_\xi(E_{\pi(\xi)})\)自然地同构于向量丛的纤维\(E_{\pi(\xi)}\). 这样，取值在\(TE\)中的“导数”就被变成了取值在\(E\)中的“导数”。</p> <p>这里投影的选择不是唯一确定的，我们没有一个自然地方式将\(TE\)投影到\(E\)，因此我们需要在\(E\)中每一点\(\xi\)处指定一个投影</p> \[\mathcal{P}_\xi: T_\xi E \rightarrow \ker (\mathrm{D}\pi\vert _{\xi}: T_\xi E \rightarrow T_{\pi(\xi)}X ) \cong E_{\pi(\xi)}\] <p>这时候，我们的协变导数可以写成：</p> \[(\nabla \xi)\vert _x = d_{\xi_x}^{-1} \circ \mathcal{P}_{\xi_x}\big((D\xi)\vert _x\big)\] <p>这里\(d_{\xi_x}: E_{x} \rightarrow T_{\xi_x}(E_{x})\)是由\(E_{x}\)的线性结构得到的自然同构，也就是将\(0\)处的切空间平移到\(\xi\)处之后得到的同构。</p> <p>最后指出一点：线性空间的投影\(P: V \rightarrow V\)完全由它的像和核确定。在这里，\(E\)中每一点\(\xi\)处的投影\(P_\xi\)的像是\(\ker \mathrm{D}\pi_{\xi}\)，是一个已经被确定的子空间，因此在每点处指定一个投影相当于在每点处指定了一个子空间\(H_{\xi}\)，使得我们有直和分解：</p> \[T_{\xi}E = \ker \mathrm{D}\pi_{\xi} \oplus H_{\xi}\] <h3 id="注记">注记</h3> <p>在我们给出的三种理解方式里，只有联络1-形式的理解方式能很轻松地给出联络的等价定义，通过平行移动和投影都不太能简洁地给出联络的等价定义。</p> <h2 id="2-主丛和主丛上的联络">2. 主丛和主丛上的联络</h2> <p>引入主丛的一种方法是利用向量丛的结构群。对一个秩为\(r\)的向量丛\(\pi: E \rightarrow M\)，在找了\(M\)的一组开覆盖\(\{U_{\alpha}\}_{\alpha \in I}\)，使得\(E\)限制在每个\(U_{\alpha}\)上有平凡化\(\varphi_{\alpha}\)之后，平凡化之间的转移映射给出了一组转移函数</p> \[\{g_{\alpha\beta}: U_\alpha \cap U_\beta \rightarrow G \subset GL(r, \mathbb{R})\}_{\alpha, \beta \in I}\] <p>使得</p> \[\varphi_{\alpha} \circ \varphi_{\beta}^{-1}(x, v) = (x, g_{\alpha\beta}(x)\cdot v), \forall x \in U_\alpha \cap U_\beta, v \in \mathbb{R}^r\] <p>这里的群\(G\)就被称作向量丛\(E\)的结构群。</p> <p>转移函数告诉了我们，如何将一组平凡丛\(\{U_{\alpha}\times \mathbb{R}^r\}_{\alpha \in I}\)粘接成向量丛\(E\)，也就是我们有向量丛的同构：</p> \[E \cong \left(\amalg_{\alpha \in I} U_\alpha \times \mathbb{R}^r\right)/(x, v) \sim (x, g_{\alpha\beta}(x)v)\] <p>这也告诉我们，一个向量丛的转移函数实际上蕴含了这个向量丛的所有信息，因此有关向量丛的问题都可以视作有关转移函数和群的问题。这时候，我们定义：</p> \[\mathrm{Fr}_G(E) = \left(\amalg_{\alpha \in I} U_\alpha \times G\right)/(x, h) \sim (x, g_{\alpha\beta}(x)\cdot h)\] <p>这是一个在\(M\)上的、纤维为\(G\)的纤维丛，它蕴含着原本的向量丛\(E\)的所有信息，且从转移映射的角度来说，这个几何对象更加自然。</p> <p>我们定义的\(\mathrm{Fr}_G(E)\)是主丛的一个例子。一般的，我们有下面的定义：</p> <blockquote> <p><strong>定义</strong>：对给定的李群\(G\)，如果一个纤维丛\(\pi: P \rightarrow M\)以\(G\)为纤维，且\(G\)能够光滑地右作用在\(P\)上，使得\(G\)的作用保持每个纤维不动，且在每个纤维上是自由、传递的，就称\(P\)是一个\(G\)-主丛。</p> </blockquote> <p>这里一个没有那么严谨的地方是：\(G\)-主丛的纤维实际上不是\(G\)，而是所谓的<a href="https://en.wikipedia.org/wiki/Principal_homogeneous_space">\(G\)-torsor</a>，或\(G\)-主齐性空间。一个李群\(G\)的主齐性空间和这里李群本身是微分同胚的，但\(G\)-主齐性空间上没有群结构，只有\(G\)的右作用。</p> <p>利用配丛的概念，我们可以从一个\(G\)-主丛构造出一个向量丛。假设在有了\(G\)-主丛\(P\)和群\(G\)在线性空间\(V\)上的一个表示\(\rho: G \rightarrow GL(V)\)之后，我们可以定义出\(P\)的配丛\(P\times_{\rho}V\)，它是一个以\(V\)为纤维的向量丛：</p> \[P\times_{\rho}V := \left(P \times V\right)/G\] <p>这里\(G\)通过下面的方式左作用在\(P \times V\)上：</p> \[h \cdot (p, v) = (p\cdot h^{-1}, \rho_{h}v), \forall h \in G, p \in P, v \in V\] <p>比如我们之前定义的\(\mathrm{Fr}_{G}(E)\)在\(\mathbb{R}^r\)，通过将\(G\)嵌入到\(GL(r, \mathbb{R})\)中，我们可以得到一个表示\(\iota\)，这时候我们的配丛\(\mathrm{Fr}_{G}(E) \times_{\iota} \mathbb{R}^r\)恰好同构于向量丛\(E\).</p> <h3 id="21-主丛上的联络">2.1. 主丛上的联络</h3> <p>我们接下来给出主丛上联络的定义。</p> <blockquote> <p><strong>定义</strong>：一个\(G\)-主丛\(\pi: P \rightarrow M\)上的联络是\(P\)的切丛\(TP\)的一个子丛\(H\)，使得在\(P\)上每一点\(p \in P_x\)处，有直和分解</p> \[T_pP = T_p(P_x) \oplus H_p\] <p>且\(H\)在\(G\)的右作用下不变。</p> </blockquote> <p>注意到，上面的直和分解实际上给出了在每一点\(p \in P_x\)处的投影映射</p> \[\mathcal{P}_p: T_pP \rightarrow T_p(P_x) = \ker \mathrm{D}\pi_p\] <p>因此，我们可以给出下面的等价定义：</p> <blockquote> <p><strong>定义</strong>：\(G\)-主丛\(P\)上的联络是一个向量丛的投影</p> \[\mathcal{P}: TP \longrightarrow \ker \mathrm{D}\pi\] <p>使得对任意的\(g \in G\)，有\(g_{*} \circ \mathcal{P} = \mathcal{P} \circ g_{*}\). 这里\(g_{*}\)表示由\(G\)在\(P\)上的右作用诱导的\(TP\)上的右作用\(g_{*}: TP \rightarrow TP\).</p> </blockquote> <p>因为\(g_{*}\)给出了\(G\)在\(P\)的切丛\(TP\)上的左作用，这时候定义中的等式\(g_{*} \circ \mathcal{P} = \mathcal{P} \circ g_{*}\)相当于说，投影\(\mathcal{P}\)是\(G\)-等变的。所以联络的定义可以简短地叙述为：主丛上的联络是从它的切丛到它纤维的切丛的一个\(G\)-等变的投影。</p> <p>另外可以看出来，这一定义对应着向量丛上联络的第三种看法：将联络看作丛投影。我们接下来解释如何从主丛上的联络得到联络1-形式和主丛上的平行移动。</p> <h4 id="211-联络1-形式">2.1.1. 联络1-形式</h4> <p>从定义得到联络1-形式\(\omega \in \Omega(P; \mathfrak{g})\)是相对轻松的。我们只需要稍微修改一下投影\(\mathcal{P}\)的值域即可。</p> <p>注意到，每个纤维\(P_x\)是一个\(G\)-主齐性空间，所以纤维\(P_x\)上任意一点\(p\)处的切空间\(T_p(P_x)\)和\(\mathfrak{g}\)之间存在一个典则同构：</p> \[\begin{aligned} d_p: \mathfrak{g} &amp; \xrightarrow{\cong} T_p(P_x) \\ u &amp; \longmapsto X_u=\frac{\mathrm{d}}{\mathrm{d}t}\bigg\vert _{t = 0}p\cdot\exp(tu)\\ \end{aligned}\] <p>我个人更喜欢用另一种方式理解这一典则同构：\(G\)在每根纤维上的作用是传递的，意味着任意一根纤维上每个点的地位是对等的（比如任选一个点，都能以它为基点将这根纤维等同于\(G\)），每一点的切空间在相差一个\(G\)的作用的意义下是相同的，而容易看出一点处的切空间等同于\(\mathfrak{g}\)，因此我们可以构造这一典则同构。</p> <p>有了典则同构\(d_p\)之后，我们可以在每一点\(p \in P_x\)处定义李代数值的联络1-形式：</p> \[\omega_p := d_p^{-1}\circ\mathcal{P}_p: T_pP \longrightarrow \mathfrak{g}\] <p>此外，由\(\mathcal{P}\)的性质可以得到联络1-形式的性质。\(\mathcal{P}\)是投影等价于对任意李代数中元素\(u\)，有\(\omega_{p}(X_u) = u\). \(\mathcal{P}\)是\(G\)-等变的等价于\(\omega\)是\(G\)-等变的，也就是\((g^{*}\omega)_{p} = \mathrm{Ad}_{g^{-1}} \circ \omega_{p}\)，其中\(\mathrm{Ad}_{g}\)是\(G\)在\(\mathfrak{g}\)上的伴随作用。这使得我们可以用联络1-形式给出联络的等价定义：</p> <blockquote> <p><strong>定义</strong>：一个\(G\)-主丛\(P\)上的联络是\(P\)上一个李代数值的1-形式</p> \[\omega: TP \longrightarrow \mathfrak{g}\] <p>使得对任意的\(g \in G\)和\(u \in \mathfrak{g}\)，有</p> <ul> <li> \[\omega(X_u) = u\] </li> <li> \[g^*\omega = \mathrm{Ad}_{g^{-1}}\circ \omega\] </li> </ul> </blockquote> <p>在大部分时候，这一定义是更加常用的，因为\(\omega\)可以方便地参与到许多的运算中，而投影\(\mathcal{P}\)不能。比如类似向量丛的情形，我们可以用联络1-形式轻松地写出联络的曲率：</p> \[\Omega = \mathrm{d}\omega + \frac{1}{2}[\omega, \omega]\] <p>其中\([\omega, \eta]\)被定义为</p> \[[\omega, \eta](X, Y) = [\omega(X), \eta(Y)] - [\omega(Y), \eta(X)]\] <p>在进入有关平行移动的讨论之前，我们说明一下联络1-形式的局部表示。选取底空间\(M\)中的一个开集\(U\)和\(U\)上的局部截面\(s: U \rightarrow P\)。这时我们可以得到\(U\)上的1-形式：</p> \[s^*\omega \in \Omega^1(M; \mathfrak{g})\] <p>这被称作联络1-形式\(\omega\)在\(U\)上的局部表示。注意到\(\omega\)的局部表示依赖于截面\(s\)的选取，因此一般不能将\(s^{*}\omega\)粘接为某个全局1-形式\(\tilde{\omega} \in \Omega^{1}(M,\mathfrak{g})\). 我们后面会看到，\(s^{*}\omega\)对应着向量丛的联络1-形式。</p> <p>此外利用拉回的自然性我们可以得到局部上曲率的计算方式：</p> \[s^*\Omega = \mathrm{d}(s^*\omega) + \frac{1}{2}[s^*\omega, s^*\omega]\] <h4 id="212-平行移动">2.1.2 平行移动</h4> <p>利用联络\(\mathcal{P}\)也可以定义主丛上的平行移动。</p> <p>对底空间\(M\)上的曲线\(\gamma: [a, b] \rightarrow M\)，沿着\(\gamma\)的截面\(s: [a, b] \rightarrow P\)被称为平行于\(\gamma\)的截面，如果对任意的\(t \in [a, b]\)，有</p> \[\mathcal{P}\bigl(\dot{s}(t)\bigr) = 0\] <p>如果用联络1-形式来叙述的话，\(s\)与\(\gamma\)平行当且仅当对任意的\(t\)，有\(\omega\bigl(\dot{s}(t)\bigr) = 0\).</p> <p>这里的平行可以和向量丛中的平行截面类似理解。切向量\(\mathcal{P}(\dot{s}(t)) \in T_{s(t)}P_{\gamma(t)}\)反映了截面\(s\)沿着纤维方向的变化量，因此起到了原先协变导数的作用。而这个量等于\(0\)就意味着截面\(s\)关于联络\(\mathcal{P}\)沿着纤维没有变化，因此可以看作平行于曲线\(\gamma\).</p> <p>在局部坐标上讨论的话，一个截面\(s\)平行于\(\gamma\)会等价于\(s\)的局部坐标满足某个一阶常微分方程，所以根据常微分方程的理论可以知道，在给定初值\(s(a)\)的情形下，存在唯一平行于\(\gamma\)的截面，且这个截面光滑地依赖于初值\(s(a)\)的选取。</p> <p>因此，在固定时间\(t\)，只改变初值的时候，我们会得到一个映射</p> \[\mathscr{P}_{\gamma}^{0 \to t}: P_{\gamma(0)} \longrightarrow P_{\gamma(t)}\] <p>一般地，我们会有\(\mathscr{P}_{\gamma}^{a \to b}: P_{\gamma(a)} \rightarrow P_{\gamma(b)}\). 我们把这一映射叫做沿着\(\gamma\)的平行移动。</p> <p>一个值得注意的地方是，平行移动是保持\(G\)-torsor结构的，或者说平行移动作为映射是\(G\)-等变的。这可以从\(\mathcal{P}\)是\(G\)-等变的推出。此外，类似向量丛，我们从平行移动也可以重建出联络的信息。对\(P\)的切向量\(X \in T_pP\)，选取一个从\(p \in P_x\)出发，初速度为\(X\)的曲线\(\tilde{\gamma}\)，它在\(M\)上的投影是一条曲线\(\gamma\). 这时候我们有关系式：</p> \[\mathcal{P}(X) = \dot{s}(0)\] <p>其中\(s(t) = \mathscr{P}_{\gamma}^{t \to 0}\tilde{\gamma}(t)\)是\(P_x\)上的曲线。</p> <h3 id="22-从主丛的联络到配丛的联络">2.2. 从主丛的联络到配丛的联络</h3> <p>这一节我们来解释主丛的联络和配丛的联络之间的关系。更严格地说，我们解释如何从主丛上的联络得到配丛上的联络。我们假设\(\pi: P \rightarrow M\)是一个\(G\)-主丛，其上的联络为\(\omega \in \Omega^1(P; \mathfrak{g})\). \(G\)的一个表示\(\rho: G \rightarrow GL(V)\)给出了\(P\)的一个配丛</p> \[\pi_E: E = P \times_{\rho} V \longrightarrow M\] <p>我们将解释主丛上的联络如何给出配丛上的丛投影、平行移动和联络1-形式。并在附录中给出用平行移动定义和用联络1-形式定义的等价性。</p> <p>我们先看如何定义\(E\)上的丛投影。主丛\(P\)上的丛投影给出了切丛\(TP\)的子丛\(HP\)，这一子丛可以被自然地提升为\(T(P\times V)\)的子丛：</p> \[p^*HP := \bigsqcup_{(p, v) \in P \times V} H_pP \oplus 0\] <p>其中\(p: P \times V \rightarrow P\)是自然投影。又注意到商映射</p> \[q: P \times V \longrightarrow P\times_{\rho}V\] <p>的切映射将\(T_{(p, v)}(P \times V)\)映为\(T_{[(p, v)]}E\)，因此\(p^*HP\)也被映为了\(TE\)的一个子丛\(HE\). 注意到\(HP\)在\(G\)作用下是不变的的，因此尽管\(P \times V\)中许多点会被映到了\(E\)上的一个点\([(p, v)]\)，但这些点处的“水平丛”被映为\(TE\)的同一个子空间，因此\(HE\)是良定的。\(HE\)定义了一个丛投影</p> \[\mathcal{P}_E: TE \longrightarrow \ker \pi_E\] <p>利用这个丛投影就可以给出\(E\)上的联络。验证这是一个联络的办法是直接写出它的联络1-形式。我们略去具体的计算过程。</p> <p>另一个办法是利用平行移动。对任意一条曲线\(\gamma: \mathbb{R} \rightarrow M\)，它定义了\(P\)上的平行移动\(\mathscr{P}_{\gamma}^{a \to b}\). 由此我们可以得到\(P \times_{\rho} V\)上的平行移动：</p> \[\begin{matrix} \mathscr{P}_{\gamma, E}^{a \to b}: &amp; E_{\gamma(a)} &amp; \longrightarrow &amp; T_{\gamma(b)}E \\ &amp; [(p, v)] &amp; \longmapsto &amp; [(\mathscr{P}_{\gamma}^{a \to b}(p), v)] \end{matrix}\] <p>注意到平行移动\(\mathscr{P}_{\gamma}^{a \to b}\)是\(G\)-等变的，所以\(\mathscr{P}_{\gamma, E}^{a \to b}\)不依赖于代表元\((p, v)\)的选取，是良定的。这时候我们可以定义\(E\)上的联络为：</p> \[\nabla_{\dot{\gamma}(0)}X = \lim_{t \to 0} \frac{\mathscr{P}_{\gamma,E}^{t \to 0}X_{\gamma(t)}- X_{\gamma(0)}}{t}\] <p>在不作具体计算的情况下，用联络1-形式定义\(E\)上的联络是最快的。在选取了\(P\)的一个局部截面\(s: U \rightarrow P\)之后，\(s\)给出了\(E\)的局部平凡化：</p> \[\begin{matrix} \varphi: &amp; E\vert _{U} &amp; \longrightarrow &amp; U \times V \\ &amp; [(s(x), v)] &amp; \longmapsto &amp; (x, v) \end{matrix}\] <p>在这一平凡化下，我们规定\(E\)上联络的联络1-形式为</p> \[\omega_E = \rho_*(s^*\omega) \in \Omega^1(U, \mathrm{End}(V))\] <p>其中\(\rho_*: \mathfrak{g} \rightarrow \mathrm{End}(V)\)是由\(\rho\)定义的前推。</p> <p>我们可以进一步写出这个联络的曲率的局部表示：\(\Omega_E = \rho_*(s^*\Omega)\).</p> <h2 id="附录联络1-形式的计算">附录：联络1-形式的计算</h2> <p>这里附上用平行移动计算配丛上联络1-形式的过程，其中\(P \rightarrow X\)是主丛：</p> <blockquote> <p>Assume that \(E = P \times_{\rho} \mathbb{K}^r\).</p> <p>Since \(P\) is locally trivial, we can choose a open neighborhood \(U \subseteq X\) such that there is a section \(s: U \rightarrow P\). The section \(s\) yields a local trivialization \(\Phi: E\vert _U \rightarrow U \times \mathbb{K}^r\) whose inverse is</p> \[\Phi^{-1}: \big(x, (y^1, \dots, y^r)\big) \longmapsto [s(x), (y^1, \dots, y^r)]\] <p>For a curve \(\gamma: [0, 1] \rightarrow U\) with \(\gamma(0) = x\) and \(\dot{\gamma}(0) = u\), its horizontal lift \(\tilde{\gamma}\) is of the form:</p> \[\tilde{\gamma}(t) = s(\gamma(t)) \cdot g(t)\] <p>where \(g: [0, 1] \rightarrow G\) is smooth. Without loss of generality, we assume that \(g(0) = e\). Since \(\tilde{\gamma}\) is horizontal, we have</p> \[\begin{aligned} 0 = \omega(\dot{\tilde{\gamma}}(0)) &amp; = \omega\bigl((R_{g(0)})_*ds_x(\dot{\gamma}(0)) + \Theta(\dot{g}(0))^{\sharp}_x\bigr)\\ &amp; = \omega((R_{g(0)})_*ds_x(u)) + \Theta(\dot{g}(0)) \end{aligned}\] <p>where \(\Theta\) is the Maurer-Cartan form on \(G\).</p> <p>Note that \(g(0) = e\), so we have:</p> \[\dot{g}(0) = - (s^*\omega)(u)\] <p>The curve \(\tilde{\gamma}\) induces the parallel transport</p> \[\tau^{E, \omega}_{\gamma\vert _{[0, t]}}: [s(x), \vec{y}] = [\tilde{\gamma}(0), \vec{y}] \longmapsto [\tilde{\gamma}(t), \vec{y}] = [s(\gamma(t)), \rho\bigl(g(t)\bigr)\vec{y}]\] <p>So for \(\psi \in \Gamma(E\vert _U), \psi_{x'} = [x', \vec{y}(x')]\) we have</p> \[\begin{aligned} \nabla^{\omega}_u \psi &amp; = \frac{d}{dt}\bigg\vert_{t=0} \left(\tau^{E, \omega}_{\gamma\vert _{[0, t]}}\right)^{-1}(\psi_{\gamma(t)}) \\ &amp; = \frac{d}{dt}\bigg\vert_{t=0} [s(x), \rho\bigl(g(t)^{-1}\bigr)\cdot \vec{y}(\gamma(t))]\\ &amp; = [s(x), - \bigl(\rho_*\dot{g}(0)\bigr)\cdot \vec{y}(0) + \rho(g(0)) \cdot \frac{d}{dt}\vec{y}(0)] \end{aligned}\] <p>We already know that \(g(0) = e\) and \(\dot{g}(0) = - (s^*\omega) (u)\), so we have:</p> \[\begin{aligned} \nabla^{\omega}_u \psi &amp; = [s(x), \rho_*(s^*\omega(u)) \cdot \vec{y} + \frac{d}{dt}\vec{y}(0)] \\ &amp; = [s(x), \rho_*(s^*\omega(u)) \cdot \vec{y} + u(\vec{y})] \end{aligned}\] </blockquote>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[To record three usual ways to think of connections on vecter bundles.]]></summary></entry><entry><title type="html">Bounded Operators Can Not Satisfy Canonical Commutative Relation(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Bounded-Operators-Can-Not-Satisfy-Canonical-Commutative-Relation/" rel="alternate" type="text/html" title="Bounded Operators Can Not Satisfy Canonical Commutative Relation(In Chinese)"/><published>2024-06-11T14:05:16+00:00</published><updated>2024-06-11T14:05:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Bounded-Operators-Can%20-Not-Satisfy-Canonical-Commutative-Relation</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Bounded-Operators-Can-Not-Satisfy-Canonical-Commutative-Relation/"><![CDATA[<p>这篇的目的是记录下面的定理和它的证明：</p> <blockquote> <p><strong>定理</strong>：设\(P, Q\)是Hilbert空间\(\mathscr{H}\)上的算子，且满足</p> \[PQ - QP = i \cdot \mathrm{id}_{\mathscr{H}}\] <p>那么\(P, Q\)中至少有一个是无界算子。</p> </blockquote> <h2 id="一点背景量子化">一点背景：量子化</h2> <p>一种解释<a href="https://en.wikipedia.org/wiki/Canonical_quantization">量子化</a>的方式是，人们希望建立量子力学和经典力学之间的联系，而建立的办法就是，直接给出通常的物理量和量子力学中的物理量（也就是某个Hilbert空间\(\mathscr{H}\)上的算子）的对应关系。用稍微数学一些的话来说，我们期望找到一个映射：</p> \[\begin{matrix} \mathscr{Q}: &amp; \{\text{物理量}\} &amp; \longrightarrow &amp; \{\mathscr{H}\text{上算子}\} \\ &amp; u &amp; \longmapsto &amp; \hat{u}: \mathscr{H} \rightarrow \mathscr{H} \end{matrix}\] <p>更进一步，我们希望这个映射能够保持一些运算，使得我们可以从经典力学的方程直接得到量子力学的方程。比如，我们希望：</p> <ul> <li>\(\mathscr{Q}\)是实线性的。</li> <li>\([\hat{u}, \hat{v}] = i \hbar \widehat{\{u, v\}}\) 这里\([\hat{u}, \hat{v}]:=\hat{u}\hat{v}-\hat{v}\hat{u}\)被叫做对易子或者交换子，\(\{\cdot, \cdot\}\)是哈密顿力学里的<a href="https://en.wikipedia.org/wiki/Poisson_bracket">Poisson括号</a>。</li> </ul> <p>举个例子，在一维的系统里，我们考虑位置\(x\)和动量\(p\)量子化。我们已经知道：</p> \[\{x, p\} = 1\] <p>因此，\(x\)和\(p\)的量子化\(\hat{x}, \hat{p}\)必须满足：</p> \[[\hat{x}, \hat{p}] = i\hbar \cdot \mathrm{id}_{\mathscr{H}}\] <p>这个等式就被叫做典则交换关系(canonical commutation relation, C.C.R.)。因为数学上，可以将\(\hbar\)吸收到\(\hat{x}, \hat{p}\)中，所以这篇文章里也将等式\(PQ-QP = i \cdot \mathrm{id}_{\mathscr{H}}\)称作C.C.R.。</p> <h2 id="定理的证明">定理的证明</h2> <p>这个定理的证明并不复杂。办法是使用反证法，假设存在两个有界算子\(P,Q\)满足C.C.R.。那么我们有这样的观察：</p> <ul> <li>如果\(P, Q\)满足C.C.R.，那么\(c \cdot \mathrm{id}_{\mathscr{H}}+P\)和\(Q\)也满足C.C.R.。</li> </ul> <p>所以我们可以取充分大的常数\(c\)，使得\(P\)是可逆的。为了方便，我们记\(R = QP\)，那么我们的C.C.R.就变成了</p> \[P R P^{-1} = R + i \cdot \mathrm{id}_{\mathscr{H}}\] <p>考虑两边算子的谱可以知道：</p> \[\sigma(R) = \sigma(PRP^{-1}) = \sigma(R) + i\] <p>这意味着，如果\(\lambda\)是\(R\)的一个谱点，那么\(\lambda + i\)也是\(R\)的谱点。所以利用归纳法可以知道，对任意的正整数\(n\)，\(\lambda + ni\)是\(R\)的谱，这样\(R\)的谱\(\sigma(R)\)一定无界。</p> <p>但由\(R = QP\)和\(P,Q\)是有界算子马上知道，\(R\)是有界算子，进而\(\sigma(R)\)必须是有界集。这样我们就得到了矛盾。</p> <h2 id="一些补充">一些补充</h2> <p>可以认为这个定理提供了研究无界算子的一个动机：量子力学必须要使用无界算子来描述物理量。</p> <p>另外注意到有限维空间上的线性算子一定是有界的，所以从这个定理可以得到下面的推论：</p> <blockquote> <p><strong>推论</strong>：如果线性空间\(V\)上的算子\(P, Q\)满足C.C.R.，那么\(V\)一定是一个无穷维（赋范）线性空间。</p> </blockquote> <p>可以认为这个推论解释了为什么量子力学需要引入Hilbert空间。</p> <p>此外，在算子\(P, Q\)无界的时候，是有可能满足C.C.R.的，比如取\(\mathscr{H} = \mathcal{L}^2(\mathbb{R})\)，再取</p> \[\begin{aligned} \big(P\psi\big)(x) &amp; = -i\frac{\mathrm{d}}{\mathrm{d}x}\psi(x) \\ \big(Q\psi\big)(x) &amp; = x \cdot \psi(x) \end{aligned}\] <p>这时候\(P, Q\)形式上满足C.C.R.。</p> <p>这里使用了“形式上”三个字是因为，无界算子的C.C.R.不能直接理解成通常的交换子。严格来说，无界算子的C.C.R.要靠有界算子\(e^{iP}, e^{iQ}\)的交换性来定义。这时候，C.C.R.被表述为所谓的<a href="https://en.wikipedia.org/wiki/Canonical_commutation_relation#Weyl_relations">Weyl关系(Weyl relations)</a>。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[The proof of the fact that two bounded operators can not satisfy the C.C.R.]]></summary></entry><entry><title type="html">Initiation to Convergence Theory(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Initiation-to-Convergence-Theory/" rel="alternate" type="text/html" title="Initiation to Convergence Theory(In Chinese)"/><published>2024-06-09T20:49:16+00:00</published><updated>2024-06-09T20:49:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Initiation-to-Convergence-Theory</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Initiation-to-Convergence-Theory/"><![CDATA[<h2 id="引入">引入</h2> <p>考虑下面的例子。</p> <p>在泛函分析里，给了一个Banach空间\(\mathscr{X}\)后，它的对偶空间\(\mathscr{X}^*\)是\(\mathscr{X}\)上全体有界线性函数构成的空间。在\(\mathscr{X}\)上可以定义两种不同的收敛：依范数收敛和弱收敛。这两种不同的收敛方式实际上来源于\(\mathscr{X}\)上的两个不同拓扑\(\tau, \tau'\)，这里\(\tau\)以</p> \[\{ B(x, r) \mid x \in \mathscr{X}, r &gt; 0 \}\] <p>为拓扑基，其中\(B(x, r)\)是以\(x\)为中心、半径为\(r\)的开球；\(\tau'\)以</p> \[\{ f^{-1}(U) \mid f \in \mathscr{X}^*, U\text{为}\mathbb{R}\text{中开集}\}\] <p>为子基(subbases)。换言之，点列\(\{x_n\}_{n \geq 1}\)依范数收敛到\(x\)当且仅当其在拓扑空间\((\mathscr{X}, \tau)\)中收敛到\(x\)；\(\{x_n\}_{n \geq 1}\)弱收敛到\(x\)当且仅当其在拓扑空间\((\mathscr{X}, \tau')\)中收敛到\(x\)。</p> <p>不过一般来说，不能轻易地知道一种收敛方式是否来源于集合上的某个拓扑。比如考虑\(\mathbb{R}\)上的全体可测函数构成的空间，可以在上面定义几乎处处收敛、近一致收敛和依测度收敛。这时候不能直接知道这些收敛方式来源于哪个拓扑。</p> <p>这启发了这样的想法：是否任何一种“极限”都可以由集合上的某个拓扑定义，而“极限”和集合上的拓扑是否又有某种一一对应关系。顺着这个想法往下走，就会得到收敛空间(convergence space)相关的理论。</p> <p>由于作者对收敛空间的了解有限，本文只是给出收敛空间的定义和基本性质。想要了解更多的话，可以参考S. Dolecki的书籍[1] [2]。R. Frič的一篇文章[3]梳理了序列收敛空间(sequential convergence spaces)的发展历史，并提供了有关收敛空间理论一些调查文章和会议文章。</p> <p>此外受限于作者的翻译水平，一些术语未必与主流的翻译相同，因此在第一次出现时，会附上对应的英文。</p> <h2 id="序列收敛">序列收敛</h2> <p>为了方便理解，我们从特殊的收敛——序列收敛(sequential convergence)——开始。数学分析（或者高等数学）里的序列极限就是一个例子。</p> <p>我们先做一步准备工作。集合\(X\)中的一个序列\(\{x_n\}_{n \geq 0}\)看作一个映射\(S: \mathbb{N} \rightarrow X\)，满足\(S(n) = x_n\).</p> <blockquote> <p><strong>例</strong>：</p> <p>(1)常值序列\(x_n = x\)就可以看成一个常值映射\(S(n) \equiv x\).</p> <p>(2)对一个序列\(\{x_n\}_{n \geq 0}\)可以取子列\(\{x_{n_k}\}_{k \geq 0}\). 取严格单调递增的映射\(t: k \mapsto n_k\)，那么子列\(\{x_{n_k}\}_{k \geq 0}\)对应于映射\(S \circ t\)，这里\(S(n) = x_n\).</p> <p>(3)集合\(X\)上全体序列构成的集合相当于所有从\(\mathbb{N}\)到\(X\)的映射构成的集合。我们将这个集合记为\(X^{\mathbb{N}}\).</p> </blockquote> <p>数学分析里面说，收敛的实数列\(\{x_n\}_{n \geq 0}\)存在唯一极限\(\lim_{n \to \infty} x_n\). 换言之，求极限实际上是给每个收敛的数列指定了的一个实数。所以我们会这样给极限定性：</p> <blockquote> <p>数列极限是一个映射：\(\lim: \{\text{全体收敛数列}\}\rightarrow \mathbb{R}\).</p> </blockquote> <p>或者更粗略地说：</p> <blockquote> <p>数列极限是集合\(\mathbb{R}^{\mathbb{N}} = \{\text{全体实数列}\}\)与集合\(\mathbb{R}\)之间的一个关系（关系的定义在本文最后）。</p> </blockquote> <p>一般的，可以给出序列收敛(sequential convergence)的定义：</p> <blockquote> <p><strong>定义</strong>：集合\(X\)上的一个<strong>序列收敛</strong>是一个\(X^{\mathbb{N}}\)与\(X\)的一个关系\(\xi\)，在\((S, x) \in \xi\)时，记\(x \in \lim_\xi S\). 我们要求\(\xi\)满足： (1)对\(x \in \lim_\xi S\)以及任意的一个子列\(S \circ t\)，有\(x \in \lim_\xi S \circ t\). (2)对常值序列\(S(n) \equiv x\)，有\(x \in \lim_\xi S\).</p> </blockquote> <p>一个具有序列收敛的集合被叫做一个<strong>序列收敛空间(sequential convergence space)</strong>。如果一个序列收敛还满足：</p> <blockquote> <p>如果\(x, y \in \lim_\xi S\)，那么\(x = y\).</p> </blockquote> <p>我们就称这是个<strong>单值序列收敛(single-valued sequential convergence)</strong>。</p> <p>Dolcher在1960年的时候就考虑了什么样的序列收敛可以通过集合上拓扑结构得到，目前最完整和最令人满意的结果由Koutník在1985年得到。</p> <h2 id="收敛空间">收敛空间</h2> <p>比序列收敛空间更一般的空间是收敛空间。</p> <h3 id="滤子">滤子</h3> <p>为了定义收敛空间，我们需要先定义什么是滤子(filter)。</p> <blockquote> <p>定义：集合\(X\)上的一个<strong>滤子</strong>是\(X\)的一个子集族\(\mathcal{F}\)，满足： (1)对\(A, B \in \mathcal{F}\)，有\(A \cap B \in \mathcal{F}\). (2)对\(A \in \mathcal{F}\)和\(A' \subseteq X\)，如果\(A \subseteq A'\)，那么\(A' \subseteq \mathcal{F}\).</p> </blockquote> <p>不难看出，\(X\)的全体子集\(2^X\)构成一个滤子，我们把它叫做<strong>退化滤子(degenerate filter)</strong>，并将其他滤子叫做<strong>非退化滤子(non-degenerate filter)</strong>。很容易证明，\(2^X\)是唯一一个包含空集的滤子，因此有时在定义滤子时，会要求\(\emptyset \notin \mathcal{F}\).</p> <p>很多时候，决定一个滤子性质的是滤子里那些“很小”的集合，这也是我们引入滤子的基(base)的原因之一：</p> <blockquote> <p><strong>定义</strong>：对于一个滤子\(\mathcal{F}\)，称\(\mathcal{B} \subseteq \mathcal{F}\)是\(\mathcal{F}\)的<strong>基</strong>，如果对任意的\(F \in \mathcal{F}\)，存在\(B \in \mathcal{B}\)，使得\(B \subseteq F\). 对于集合族\(\mathcal{B} \subseteq 2^X\)，称其为一个<strong>滤子基(filter base)</strong>，如果对\(\mathcal{B}\)中任意两个集合\(B_1, B_2\)，存在\(B_0 \in \mathcal{B}\)使得\(B_0 \subseteq B_1 \cap B_2\). 称</p> \[\mathcal{F} = \{ F \in 2^X \mid \exists B \in \mathcal{B}, \text{s.t.} B \subseteq F\}\] <p>为\(\mathcal{B}\)生成的滤子。</p> </blockquote> <p>用\(\mathcal{B}_1 \approx \mathcal{B}_2\)表示两个滤子基\(\mathcal{B}_1, \mathcal{B}_2\)生成同一个滤子。注意到\(\mathcal{F}\)本身也是\(\mathcal{F}\)的基，所以\(\mathcal{B}\)是\(\mathcal{F}\)的基可以表示为\(\mathcal{B} \approx \mathcal{F}\).</p> <p>我们可以看一些滤子的例子：</p> <blockquote> <p><strong>例</strong>： (1)对于\(A \subseteq X\)，\(A\)定义了一个<strong>主滤子(principal filter)</strong>：</p> \[(A)_{\bullet}:=\{B \in 2^X \mid A \subseteq B\}\] <p>特别的，记\((x)_{\bullet} := (\{x\})_{\bullet}\). (2)对于一个序列\(A: \mathbb{N} \rightarrow X\)，记\(A_k = \{S(n) \mid n \geq k\}\)，称由集合族\(\{A_k\}\)生成的滤子</p> \[\mathcal{S} = \{ B \in 2^X \mid \exists k \in \mathbb{N}, \text{s.t.} A_k \subseteq B\}\] <p>为\(S\)生成的<strong>序列滤子(sequential filter)</strong>，记作\(\mathcal{S} \approx A\). 在收敛空间的理论中，可以认为序列滤子和序列收敛是对应的，关于序列收敛的讨论可以转化为对序列滤子的讨论。 (3)对于一个拓扑空间\((X, \tau)\)，可以定义上面的<strong>邻域滤子(neighbourhood filter)</strong></p> \[\mathcal{N}_\tau (x) := \{N \mid \exists U \in \tau, \text{s.t.} x \in U \subseteq N\}\] <p>换言之，邻域滤子\(\mathcal{N}_\tau (x)\)是由全体包含点\(x\)的开集生成的滤子。</p> </blockquote> <h3 id="收敛">收敛</h3> <p>在定义完滤子之后，我们可以定义集合\(X\)上的收敛(congvergence)：</p> <blockquote> <p><strong>定义</strong>：集合\(X\)上的一个<strong>收敛</strong>是\(\{X上全体非退化滤子\}\)和\(X\)的一个关系\(\xi\)，对一个滤子\(\mathcal{F}\)，记</p> \[\lim{_\xi} \mathcal{F} = \{x \in X \mid (\mathcal{F}, x) \in \xi\}\] <p>我们要求\(\xi\)满足：</p> <p>(1)对两个滤子\(\mathcal{F} \subseteq \mathcal{G}\)，有\(\lim{_\xi} \mathcal{F} \subseteq \lim{_\xi} \mathcal{G}\).</p> <p>(2)对任意的\(x \in X\)，有\(x \in \lim{_\xi} (x)_{\bullet}\).</p> </blockquote> <p>我们称一个具有收敛结构的集合为一个<strong>收敛空间(convergence space)</strong>。下面的例子说明了拓扑空间一定是收敛空间：</p> <blockquote> <p><strong>例</strong>：对于一个拓扑空间\((X, \tau)\)，之前定义了邻域滤子\(\mathcal{N}_\tau (x)\)，我们定义其上的收敛为：</p> \[x \in \lim{_\tau} \mathcal{F} \iff \mathcal{N}_{\tau}(x) \subseteq \mathcal{F}\] <p>经过一点简单的论证可以知道，\(X\)上不同的拓扑定义了不同的收敛（因为不同拓扑给出不同的邻域滤子），所以这样的定义方式将拓扑空间和连续映射构成的范畴嵌入到收敛空间和连续映射构成的范畴。</p> </blockquote> <p>后面我们提到空间上的拓扑时，始终指由拓扑诱导的收敛结构；而提到拓扑空间时，始终指传统意义的拓扑空间。</p> <p>类似于拓扑的粗细，集合\(X\)上的两个收敛也可以比较粗细：</p> <blockquote> <p><strong>定义</strong>： 对于两个收敛\(\xi, \eta\)，称\(\xi\)细于(finer than)\(\eta\)（或\(\eta\)粗于(coarser than)\(\xi\)），如果对任何一个滤子\(\mathcal{F}\)，有</p> \[\lim{_\xi} \mathcal{F} \subseteq \lim{_\eta} \mathcal{F}\] <p>记作\(\xi \geq \eta\).</p> </blockquote> <p>一个集合上的所有收敛在粗细关系下构成一个偏序集，且任意一族收敛\(\Xi = \{\xi_i \mid i \in I\}\)的上确界和下确界分别为：</p> \[\bigcap_{\xi \in \Xi}\lim{_\xi} \mathcal{F}, \bigcup_{\xi \in \Xi}\lim{_\xi} \mathcal{F}\] <h2 id="用收敛构造拓扑">用收敛构造拓扑</h2> <p>由极限诱导的拓扑有一种非常快的定义方式：给定集合\(X\)上的收敛\(\xi\)后，取出所有粗于\(\xi\)的拓扑，将它们中最细的那个记作\(T\xi\). （如果想要使用这种定义，我们还需要证明\(T\xi\)的存在性和唯一性——这不是件很困难的事。）</p> <p>为了方便理解，我们使用\(T\xi\)的另一种定义方式。在拓扑空间里，开集满足下面的性质：</p> <blockquote> <p>对于一个集合\(U\)，\(U\)是开集当且仅当</p> \[U \in \mathcal{N}_\tau (x), \forall x \in U\] </blockquote> <p>结合拓扑空间中收敛的定义可以得到：</p> <blockquote> <p>在拓扑空间\((X,\tau)\)中，\(U \subseteq X\)是开集当且仅当对任意的滤子\(\mathcal{F}\)，如果\(x \in U \cap \lim{_\tau}\mathcal{F}\)，那么\(U \in \mathcal{F}\).</p> </blockquote> <p>所以在给定了一个收敛空间\((X, \xi)\)之后，称\(X\)的子集\(U\)是开集，如果对任意一个滤子\(\mathcal{F}\)，有</p> \[U \cap \lim{_\xi} \mathcal{F} \neq \emptyset \Rightarrow U \in \mathcal{F}\] <p>将所有开集构成的集合族记作\(\mathcal{O}_\xi\). 利用滤子的定义可以证明，\(\mathcal{O}_{\xi}\)满足开集的三条公理，因此\((X, \mathcal{O}_{\xi})\)是一个拓扑空间。我们将这个拓扑空间给出的收敛定义为\(T\xi\).</p> <p>利用定义可以证明\(T\xi\)的一些基本性质：</p> <blockquote> <p>(1)\((X, \mathcal{O}_{\xi})\)定义的收敛一定粗于\(\xi\). 即\(T\xi \leq \xi\). (2)如果\(\xi \leq \eta\)，那么\(T\xi \leq T\eta\).</p> </blockquote> <p>根据前面列出的开集的性质，对一个拓扑\(\tau\)，有\(T\tau = \tau\). 所以对任何一个粗于\(\xi\)的拓扑\(\tau\)，有：\(\tau = T\tau \leq T\xi\). 换言之，\(T\xi\)是所有比\(\xi\)粗的拓扑里最细的。这样我们就知道了\(T\xi\)的两个定义是等价的。</p> <p>\(T\xi\)的定义还告诉了我们一件事：如果一个收敛\(\xi\)严格细于\(T\xi\)，那么\(\xi\)不可能是一个拓扑。下面是一个例子：</p> <blockquote> <p><strong>例</strong>：设\(\nu\)是\(\mathbb{R}\)上的标准拓扑，我们定义一个新的收敛\(\mathrm{Seq}\ \nu\)：对滤子\(\mathcal{F}\)，\(x \in \lim{_{\mathrm{Seq}\ \nu}} \mathcal{F}\)当且仅当存在一个序列滤子\(\mathcal{S}\)，使得\(x \in \lim{_\nu} \mathcal{S}\).</p> <p>可以验证，\(T\mathrm{Seq}\ \nu\)恰好是\(\nu\)，因为\(\mathbb{R}\)中一个集合是闭的当且仅当它相对于取点列极限是闭的。注意到\(\mathcal{N}_{\nu}(0)\)相对于\(\nu\)的极限是\(x\)，而根据\(\nu\)中收敛点列的定义，任何一个序列滤子一定比\(\mathcal{N}_\tau(0)\)细，所以\(\mathcal{N}_{\tau}(0)\)中不含任何序列滤子，进而\(\mathcal{N}_{\tau}\)在\(\mathrm{Seq}\ \nu\)中的极限是空集。这表明\(\mathrm{Seq}\ \nu\)一定严格细于\(\nu\)，所以\(\mathrm{Seq}\ \nu\)不可能由某个拓扑空间得到。</p> </blockquote> <p>另一个更有实际意义的例子是，可以证明在大部分时候，连续函数空间\(C(X, \mathbb{R})\)中的逐点收敛和依测度收敛不能由某个拓扑得到。</p> <h2 id="附映射的定义">附：映射的定义</h2> <p>一种对映射的定义是：</p> <blockquote> <p>设\(A, B\)是非空的集合，如果按照某种确定的对应关系\(f\)，使对于集合\(A\)中的任意一个元素\(x\)，在集合\(B\)中都有唯一确定的元素\(y\)和它对应，那么就称\(f: A \rightarrow B\)为从集合A到集合B的一个映射。</p> </blockquote> <p>但本文中采取另一种更加抽象的定义方式。我们先定义两个集合之间的“关系”：</p> <blockquote> <p>集合\(A, B\)之间的<strong>关系</strong>是</p> \[A \times B = \{ (a, b) \mid a \in A, b \in B\}\] <p>的一个子集\(L\).</p> </blockquote> <p>那么映射就可以被定义为</p> <blockquote> <p>从集合\(A\)到集合\(B\)的<strong>映射</strong>是\(A, B\)之间的一个关系\(f\)，满足：</p> <p>对任意的\(a \in A\)，如果\((a, b_1), (a, b_2) \in f\)，那么\(b_1 = b_2\)</p> <p>当\((a, b) \in f\)时，记\(f(a) = b\).</p> </blockquote> <p>和上一种定义比起来，这种定义使用的几乎全是集合论的语言，不需要额外解释什么叫做“对应关系”。</p> <hr/> <h2 id="参考文献">参考文献</h2> <p>[1] Dolecki, S., 2009. An initiation into convergence theory, in: Mynard, F., Pearl, E. (Eds.), Contemporary Mathematics. American Mathematical Society, Providence, Rhode Island, pp. 115–161. <a href="https://doi.org/10.1090/conm/486/09509">https://doi.org/10.1090/conm/486/09509</a> [2]: Dolecki, S., Mynard, F., 2016. Convergence Foundations of Topology. WORLD SCIENTIFIC. <a href="https://doi.org/10.1142/9012">https://doi.org/10.1142/9012</a> [3] Frič, R., 1997. History of Sequential Convergence Spaces, in: Aull, C.E., Lowen, R. (Eds.), Handbook of the History of General Topology, History of Topology. Springer Netherlands, Dordrecht, pp. 343–355. <a href="https://doi.org/10.1007/978-94-017-0468-7_16">https://doi.org/10.1007/978-94-017-0468-7_16</a></p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[A very brief introduction to notions in convergence theory.]]></summary></entry><entry><title type="html">“Odd-dimensional” Approach to Hamiltonian Phase Flow</title><link href="https://dale-x-lee.github.io/blog/2024/Odd-dimensional-Approach-to-Hamiltonian-Phase-Flow/" rel="alternate" type="text/html" title="“Odd-dimensional” Approach to Hamiltonian Phase Flow"/><published>2024-03-17T00:53:16+00:00</published><updated>2024-03-17T00:53:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Odd-dimensional-Approach-to-Hamiltonian-Phase-Flow</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Odd-dimensional-Approach-to-Hamiltonian-Phase-Flow/"><![CDATA[<p>Let \(M\) be a manifold. Then on its cotangent bundle \(T^*M\) there is a canonical 1-form \(\eta \in \Omega^{1}(T^*M)\), defined by</p> \[\tau_{p} = \pi^* p\] <p>where \(\pi: T^*M \rightarrow M\) is the bundle projection. In certain local coordinate (p, q), such that the map \(\pi\) is \(\pi(p, q) = q\), the canonical form \(\eta\) has the form \(p\cdot \mathrm{d} q\), where the “\(\cdot\)” means the formal inner product.</p> <p>The exterior differential of canonical form is a symplectic form on the cotangent bundle \(T^*M\), called the canonical symplectic form and usually denoted by \(\omega\).</p> <p>In Hamiltonian mechanics, the phase flow \(\phi\) defined by a Hamiltonian \(H: T^*M \rightarrow \mathbb{R}\) is given by the differential equation</p> \[\omega(\cdot, \dot{\phi}(t)) = \mathrm{d}H\] <p>which is usually introduced via E-L equation.</p> <p>However, there is another way to establish this equation and prove the basic properties of a Hamiltonian phase flow, by considering an odd-dimensional manifold \(T^*M \times \mathbb{R}\) and the 1-form \(\eta = \tau - H\mathrm{d}t\).</p> <p>In general, we assume \(N\) is a manifold of dimension \(2n+1\), and \(\eta\) is a 1-form on the manifold \(N\). We further assume that the exterior differential of \(\eta\) is of rank \(2n\) at every tangent space. Note that the 1-form \(\tau - H\mathrm{d}t\) satisfies this requirement.</p> <p>Since the manifold \(N\) is of odd dimension, we know that the “determinant” of the form \(\mathrm{d} \eta\) is 0 and thus at each point up to scaling there is a unique vector \(\xi\) such that</p> \[i_{\xi}\mathrm{d} \eta = 0\] <p>Then we have integral curves of the class of 1-dimensional subspace \(\{\lambda\xi \mid \lambda \in \mathbb{R}\}\) on the manifold \(N\). Here integral curves are treated as submanifolds.</p> <blockquote> <p>In the case that the manifold is \(T^*M \times \mathbb{R}\) and the 1-form is \(\tau - H\mathrm{d}t\), by direct computaion under certain local coordinates we know that, the integral curves defined above can be parametrized by \(t\), and after doing so and projecting to the space \(M\), the curves become the Hamiltonian phase flow defined by \(H\).</p> </blockquote> <p>Next we derive some invariants of the flow on the manifold \(N\). The key idea is that, if a surface in the manifold is a disjoint union of flow lines, then the integral of \(\mathrm{d}\eta\) must be zero on the surface.</p> <p>Now, we call a integral curve an “vortex line”. As we shift a closed curve along the vortex lines, we call the surface we get a “vortex tube”. Applying our key idea to a vortex tube \(T\) with boundaries \(\gamma, \gamma'\), and utilising Stokes’ formula:</p> \[0 = \int_{T} \mathrm{d} \eta = \int_{\gamma} \eta - \int_{\gamma'} \eta\] <p>Therefore we know that:<strong>Conclusion</strong>: The integral \(\int_{\gamma} \eta\) remains unchange under the action of “shifting along the vortex lines”.</p> <blockquote> <p>In the case of \(T^*M \times \mathbb{R}\), we shift a closed \(\gamma\) in \(T^*M\) carefully so that at every moment, the closed curve stays in a slice \(T^*M \times {t_0}\) of \(T^*M \times \mathbb{R}\), so we know that</p> \[\int_{\gamma} \tau = \int_{\gamma} \tau - H\mathrm{d}t = \int_{\gamma'} \tau - H\mathrm{d}t =\int_{\gamma'}\tau\] <p>Note that, we already knowed the vortex lines are phase flows, so the closed \(\gamma\) actually transforms to the closed \(\gamma'\) via the 1-parameter transformation group \(\{g_t\}\) generated by the flow. So we know that:</p> \[\int_{\gamma} \tau = \int_{g_t\gamma} \tau\] <p>Applying the Stokes’ formula again we get:</p> <p><strong>Conclusion</strong>: For any disk \(D\) in \(T^*M\), we have</p> \[\int_{D} \mathrm{d}\tau = \int_{g_tD} \mathrm{d}\tau\] <p>This told us that the phase flow preserves the canonical symplectic form on \(T^*M\), which coincides with Louiville’s theorem.</p> </blockquote> <hr/> <h2 id="some-related-stuff">Some Related Stuff</h2> <p>There are some applications of this construction. One is that, it helps us to simplify the original Hamiltonian system. In our construction, it is the form \(\mathrm{d} \eta\) but not \(\eta\) that determines the vortex lines, so we can replace \(\eta\) by another form \(\eta + \mathrm{d}f\)，and solve the Hamiltonian induced by \(\eta + \mathrm{d}f\), which may be simpler.</p> <p>Besides, note that when a curve \(\gamma\) in \(T^*M \times \mathbb{R}\) is lifted from a curve \(c\) in \(M\), the integral \(\int_{\gamma}\tau - H\mathrm{d}t\) is exactly the integral of the Lagrangian along the curve \(c\), so this construction can be viewed as an extension of action principal. Further note that, the variation of the integral \(\int_{\gamma}\tau - H\mathrm{d}t\) along a vortex line is the same as integrating \(\mathrm{d}\eta\) on an “infinitely small parallelogram passing through the vortex direction” and hence is zero. This tells us that just like Lagrangian mechanics, vortex lines are critic lines of the integral \(\int_{\gamma}\tau - H\mathrm{d}t\).</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[This is a short note on the chapter 9 in the book Mathematical Methods of Classical Mechanics by Arnold.]]></summary></entry></feed>